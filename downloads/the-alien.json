{
  "ver": "0.1",
  "info": {
    "id": "sdGSzt",
    "date": "1635099465",
    "viewed": 2870,
    "name": "The Alien",
    "username": "dean_the_coder",
    "description": "Following the theme of 'lets make a shader about a movie I like', may I present 'The Alien'. :D",
    "likes": 21,
    "published": 3,
    "flags": 0,
    "tags": [
      "3d",
      "raymarching",
      "animation",
      "alien",
      "gyroid",
      "movie",
      "cineshader"
    ],
    "hasliked": 0,
    "usePreview": 0
  },
  "renderpass": [
    {
      "inputs": [],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "// 'The Alien' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/sdGSzt (YouTube: https://youtu.be/2QoR8L16Lc0)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I nearly gave up several times on this shader. I knew modelling\n// a human face would be hard, so thought attempting an alien would\n// be easier. No two 'alien' references seem to be the same, so\n// I can use artistic license. Also there's no eyes/node to get wrong.\n// I'm quite happy with the result, but the body could do with some arms.\n// But hey - The framerate is still acceptable (for me), so...\n//\n// I'm also trying to improve my animation skills. I've added some\n// 'anticipations', where before a strike the alien pulls back a bit\n// to build up some 'power'.\n//\n// The skull pattern was simpler than I was expecting - I just threw\n// a simple gyroid at it and it looked good! Surprising! And fast\n// to calculate in real-time.\n//\n// Tricks to get the performance:\n//   - No 'max dist' needed in raymarching loop (all rays hit something).\n//   - Only the skull is reflective, and that reflects just a fake sky.\n//     (I know there's no sky in a corridor, but it looks good!)\n//   - I precalculate two smooth noises variables in the lighting\n//     code and reuse them as much as possible.\n//   - Lots of domain repetition.\n//     E.g. Each jaw only has one tooth!\n//          There's only one SDF for the wall pipe.\n//          The Weyland-Yutani logo is _nearly_ just one line.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, and a bunch\n// of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define U\tnormalize\n#define L\tlength\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) { return -smin(-a, -b, k); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn L(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(L(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + L(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn L(p) - r;\n}\n\nfloat arc(vec3 p) {\n\tp.x -= -3.83333;\n\tvec2 v = vec2(-.56464, .82534),\n\t     q = p.xy - 2. * v * max(0., dot(v, p.xy));\n\tv = vec2(-3.83333, 0);\n\tfloat u = -v.x - L(q);\n\treturn sqrt((q.y < 0. ? dot(q + v, q + v) : u * u) + p.z * p.z) - max(.001, .8 - (p.y > 0. ? atan(-p.y, p.x) * v.x : -p.x < 0. ? p.y : 4.6 - p.y) * .06);\n}\n\nfloat backInOut(float x) {\n\tfloat f = x < .5 ? 2. * x : 1. - (2. * x - 1.),\n\t      g = pow(f, 3.) - f * sin(f * 3.141);\n\treturn x < .5 ? .5 * g : .5 * (1. - g) + .5;\n}\n\nfloat bone(vec3 p, float h, float r, float s) {\n\tfloat f = S(.7, 1., abs(p.x / h - .5) * 2.) * .05 * s;\n\tp.y = abs(p.y) - f;\n\treturn cap(p, h, r - f * .6);\n}\n\nfloat sky(vec3 rd) {\n\tfloat d = 10. / rd.y,\n\t      den = 1.;\n\tif (d < 0.) return 0.;\n\tvec3 p = rd * d + vec3(1, .2, 1) * t * .8;\n\tp.xz *= .2;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.12 * fbm(p));\n\n\treturn S(.9, 1., den) * (1. - sat(d / 64.));\n}\n\nfloat th(inout vec3 p) {\n\tfloat f = atan(p.z, p.x) + .25087;\n\tp.xz = L(p.xz) * cos(mod(f, .26174) - .13087 + vec2(0, 1.57));\n\tp = vec3(.04 - p.y, p.x - .36, p.z);\n\tf = .45 + abs(floor(f * 2.) * .01);\n\treturn cap(p, f, .05 * S(0., f * 1.5, cos(abs(p.x / f * 1.86 - 1. + p.x))));\n}\n\nHit map(vec3 p) {\n\tHit h;\n\th.d = 1e7;\n\tfloat d, lip, at, f, nd, s, O, x, o,\n\t      ph = S(0., 5., t);\n\tp.x -= 12. * (1. - ph);\n\tp.xz *= rot(sin(t * .5) * .02);\n\tp.yz *= rot(sin(t) * .01);\n\tvec3 r, np, pp,\n\t     op = p;\n\n\t// Corridor.\n\tp.xz *= mat2(.96891, -.2474, .2474, .96891);\n\tp.y = abs(p.y);\n\tp.z -= 30.;\n\td = -p.z - 2.;\n\tp.yz *= mat2(.87758, -.47943, .47943, .87758);\n\tp.y -= 2.5;\n\tminH(min(d, -p.z), 6, p);\n\tp.x = abs(p.x + 3.) - 15.;\n\tminH(box(p - vec3(0, 8.5, 0), vec3(5, 2.3, .1)), 8, p - vec3(0, 8.5, 0));\n\n\t// Pipework.\n\td = L(p.yz - vec2(14, 0)) - 1.5;\n\tp.y = abs(p.y - 2.5) - 1.1;\n\tminH(min(d, L(p.yz) - .8), 7, p);\n\n\t// Anim.\n\tlip = 0.;\n\tr = vec3(0);\n\n\t// Walk on.\n\top.x += 16. * (1. - ph);\n\tr.xy = sin(ph * 12.566 + vec2(0, 8)) * vec2(.05, .1) * S(1., .5, ph * ph);\n\tr.z = -r.x * .5;\n\top.y += abs(r.x);\n\n\t// Slight turn.\n\tph = S(4., 8., t);\n\tr.xy = mix(r.xy, sin(backInOut(ph) * -.25132 + vec2(0, 8)) * vec2(1, .12), S(0., .2, ph));\n\n\t// Sniff.\n\tph = S(8.2, 12., t);\n\tlip = abs(sin(ph * 6.283));\n\tr.x += sin(ph * -3.142) * .015;\n\n\t// Face forward.\n\tr.xy *= S(14., 11.5, t);\n\n\t// Whip-round anticipation.\n\tph = S(14.5, 15., t);\n\tr += vec3(.1, .05, .1) * ph;\n\top.y += ph * .1;\n\n\t// Whip.\n\tph = S(15., 15.3, t);\n\tr = mix(r, vec3(-.5, .12, 0), ph);\n\n\t// Mouth open.\n\tat = S(15.3, 20., t) * .2;\n\tf = S01(at * 30.);\n\tlip += f;\n\tr.yz = mix(r.yz, vec2(.34, -.1 + sin(t) * .07), at * 5.);\n\n\t// Inner mouth open.\n\tat += S(20., 23., t) * .25;\n\n\t// Strike anticipation.\n\top.z -= S(24., 24.2, t) * .5;\n\n\t// Strike.\n\tph = S(24.2, 24.5, t);\n\top.z += ph * 1.5;\n\tat += ph * .4;\n\n\t// Withdraw.\n\tph = S(29., 32., t);\n\tat += ph;\n\top.z -= ph;\n\tr.y *= S(34., 31., t);\n\n\t// Body position.\n\top += vec3(.9, 1.3, -3.6);\n\top.yz *= rot(r.y + .2);\n\top.xz *= rot(r.x - .2);\n\tr *= 3.;\n\n\t// Spine.\n\tp = op;\n\tp.xy *= mat2(-.73739, -.67546, .67546, -.73739);\n\tp.x++;\n\td = cap(p + vec3(0, .68, 0), 4., .1 + abs(sin(p.x * 26.) * .04));\n\tminH(d, 2, p);\n\n\t// Neck/body.\n\tp.z *= 1. - mix(.4, 1.2, S01(p.x)) * .42;\n\tf = abs(sin(p.x * 15.) * .07);\n\tf *= S(.01, .05, abs(p.z));\n\tf += S(0., .3, p.x) * .6 * S01(p.y);\n\tnd = cap(p, 4., mix(.3, .5, S01(p.x)) * (1. + f));\n\tnp = p;\n\n\t// Rotate head.\n\tp = op - vec3(1, .4, 0);\n\tr *= .5;\n\tp.xz *= rot(r.x);\n\tp.yz *= rot(r.z);\n\tp += vec3(1, .4, 0);\n\top = p;\n\n\t// Skull.\n\tp = op;\n\tp.x -= 1.5;\n\tp.xy *= mat2(.85252, -.52269, .52269, .85252);\n\tp.xy = vec2(p.y - 1., -p.x);\n\td = arc(p);\n\tp = op - vec3(.9, 0, 0);\n\tp.xy *= mat2(.995, -.09983, .09983, .995);\n\tf = .15 - box(p, vec3(2.6, cos((p.x + .3) * .4) * 1.71 - .5, 1));\n\td = smax(d, f, .06);\n\tminH(d, 1, p);\n\n\t// Head bulk.\n\tp = op;\n\tp.y -= .86;\n\td = min(d, L(p.yz) - .3 - .04 * abs(sin(p.x * 7.7)) - .02 * abs(sin(p.x * 23.1)));\n\tminH(max(d, abs(p.x) - 2.4), 2, p);\n\n\t// Frills.\n\tp = op;\n\tp.xy += vec2(1.8, -.88);\n\tp.z = abs(p.z) - .22;\n\tp.xy *= mat2(.99281, .11971, -.11971, .99281);\n\tp.xz *= mat2(.9968, .07991, -.07991, .9968);\n\td = max(cap(p, 3.5, .2 + .05 * abs(sin(p.x * 22.)) + sin(p.x) * .1), -p.y - .14);\n\n\t// Lower organs.\n\tpp = p + vec3(-1.8, .3, 0);\n\tpp.yz /= .8 + .5 * cos(pp.x);\n\tpp.yz *= rot(pp.x * -.3 + .8);\n\tf = sin(pp.x * 35.);\n\tf = max(smin(box(pp, vec3(2, vec2(.1 + .01 * abs(f * f)))), L(abs(pp.yz) - .116) - .02, .08), abs(pp.x) - 2.);\n\tminH(min(d, f), 2, pp);\n\tif (nd < d) minH(smin(d, nd, .5), 9, np);\n\n\t// Skull bone.\n\tp.yz += vec2(.21, -.15) - sin(p.x - .2) * .14;\n\tminH(bone(p, 3.6, .08, 1.), 3, p);\n\n\t// Cheek bone.\n\tp.x -= 3.63;\n\tp.xy *= mat2(.88699, -.46178, .46178, .88699);\n\tp.yz *= mat2(.5403, .84147, -.84147, .5403);\n\td = min(d, bone(p, .65, .06 - .01 * sin(p.x * 10. - 1.), .8));\n\tminH(d, 3, p);\n\n\t// Top gums.\n\tp = op;\n\tp.xy -= vec2(2.3, .76);\n\td = max(cyl(p.xzy, vec2(.4 + S(-.15, .1, p.y) * .17 - S(.2, -.2, p.y + p.x) * .09, .2 - sin(p.y * 77.) * .02 * lip)) - .1, 2.75 * p.y + p.x - .4);\n\tminH(d, 3, p);\n\n\t// Smooth connect organs to top gums.\n\tminH(max(max(smin(f, d, .25) + .01, -f), -d), 2, p);\n\n\t// Top teeth.\n\tp.x -= .08;\n\tminH(max(smax(th(p), p.y - .03, .02), 2.29 - op.x), 4, p);\n\n\t// Strike animation.\n\tf = S(1., .9, at);\n\ts = S(.5, .51, at);\n\tO = (S(0., .15, at) * .6 + s * .4) * f + sin(t) * .03;\n\tx = S(0., .2, at) * .22 + s * .5;\n\to = S(.15, .4, at) * .5 + s * (sin(t * 14.) - .8) * .2;\n\tx *= f * f;\n\to *= f * f;\n\n\t// Inner mouth.\n\tp = op;\n\tp.xy *= mat2(.87758, -.47943, .47943, .87758);\n\tp.xz *= rot(sin(t * 2.) * .014 * s);\n\tp.y -= 1.44;\n\tp.x -= x - .9;\n\tpp = p;\n\td = L(p.yz) - .1 - sin(p.x * 58.) * .01;\n\tp.yz = abs(p.yz) - .08;\n\td = max(smin(max(d, -d - .012), L(p.yz) - .03, .05), abs(p.x - 2.2) - .5);\n\tminH(d, 5, p);\n\tp = pp;\n\tp.y = abs(p.y) - .08;\n\tp.x -= 2.68;\n\tp.xy *= rot(o + .1);\n\tp.x -= .05;\n\tminH(smin(d, box(p, vec3(.035 + abs(sin(abs(p.z) * 81.) * .006), .008, .1)) - .014, .03), 5, p);\n\n\t// Inner teeth.\n\tp.x -= .025;\n\tp.z = abs(abs(p.z) - .034) - .017;\n\tp.y *= -1.;\n\tp.xy = p.yx;\n\td = cap(p, .06, .016 * cos(p.x * 22.));\n\tp.z = abs(pp.z) - .09;\n\tminH(min(d, cap(p, .1, .02 * cos(p.x * 17.))), 4, p);\n\n\t// Jaws.\n\to = O * -.4 - .9;\n\tp = op - vec3(1.6, .95, 0);\n\tp.xy *= rot(o);\n\tf = p.x * -.25;\n\tp.z -= clamp(p.z, -.6 - f, .6 + f);\n\td = bone(p, .9, .1 + f * .2, .8);\n\tp.x -= .9;\n\tp.xy *= mat2(.69671, .71736, -.71736, .69671);\n\td = smin(d, cap(p, .3, p.x * -.03 + .08), .1);\n\n\t// Bottom gums.\n\tp = op - vec3(1.6, .95, 0);\n\tp.xy *= rot(.8 + o);\n\tf = cyl(p.xzy * vec3(1, 1.3, 1) - vec3(.77, 0, -.73), vec2(.38 - .005 * sin(p.y * 126.), .04)) - .05;\n\tminH(smin(d, max(f, .7 - p.x), .1), 3, p);\n\n\t// Cheek skin.\n\tpp = p - vec3(.6, -.2, 0);\n\tf = S(-.32, .32, pp.y);\n\tpp.z = abs(pp.z) - .4 - f * .14;\n\tf = mix(.8, .5, O) * (.04 - .03 * sin(3.14 * f));\n\td = smin(d, min(box(pp + vec3(.2, -.2, -.05), vec3(.1 * pp.y + f, .32, 0)), box(pp, vec3(f, .35, 0))) - .02, .03);\n\tminH(d, 3, pp);\n\n\t// Bottom teeth.\n\tp.x -= .73;\n\tp.y += .9;\n\tp.xy *= mat2(-.98999, .14112, -.14112, -.98999);\n\tminH(max(max(p.x + .1, p.y + .3), th(p)), 4, p);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn U(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = L(p - lp);\n\tvec3 ld = U(lp - p);\n\tfor (float i = Z0; i < 25.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return sat(map(h * n + p).d / h); }\n\nvec3 strobe(vec3 p, vec3 c) {\n\tp.x -= 1.5;\n\tvec2 q = p.xz * rot(t * 2.);\n\treturn mix(c, pow(c, vec3(.7, 1, 1)), S(.8, .6, abs(q.x / q.y)));\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tvec3 ld = U(vec3(6, 3, -10) - p), c;\n\tvec2 spe = vec2(10, 1);\n\tfloat ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\t      nh = n31(h.p * 55.),\n\t      nl = n31(h.p * 23.);\n\tif (h.id == 1) {\n        // Gyroid.\n\t\tc = pow(abs((vec3(.005, .01, .01) * dot(sin(h.p * 26.), cos(h.p.zxy * 26.))\n\t\t + nh * .0046) * .5), vec3(1.12, map(ld + p).d * -.07 + 1.46, 1.43));\n\t\tc *= 1. - (.9 * S01(.9 + dot(rd, n)) + .5);\n\t\tspe = vec2(5, 28);\n\t}\n\telse if (h.id == 2 || h.id == 5 || h.id == 9) {\n\t\tc = vec3(ao * .001);\n\t\tc += S(.8, 1., ao) * vec3(1.4, 1.4, 1) * .009;\n\t\tc *= nh;\n\t\tc += 1e-4;\n\t\tspe = vec2(30. * ao, 3);\n\t\tif (h.id == 5) {\n\t\t\tc *= 4.5;\n\t\t\tspe = vec2(3, 13);\n\t\t}\n\t}\n\telse if (h.id == 3) {\n\t\tc = vec3(.56, .5, .6) * .001;\n\t\tc += S(.09, .88, abs(n.y) * nh) * .002 * vec3(1, .62, .65);\n\t\tn += (nl - .5) * .08;\n\t\tspe = vec2(18, 20);\n\t}\n\telse if (h.id == 6) {\n\t\tc = vec3(.01 + nl * .01);\n\t\tspe = vec2(19, 1);\n\t}\n\telse if (h.id == 7) {\n\t\tc = vec3(.03 + nl * .02);\n\t\tspe = vec2(42, 50);\n\t}\n\telse if (h.id == 8) {\n\t\th.p *= .3;\n        if (p.y < 0.0) h.p.y *= -1.;\n\t\tfloat w1 = abs(abs(abs(h.p.x) - .5) - h.p.y - .25);\n\t\tc = 5e-4 + min2(step(abs(h.p.xy), vec2(1.2, .4))) * (vec3(1, 1, 0) * S(.2, .15, w1) + vec3(.5) * S(.2, .15, min(abs(abs(h.p.x) - h.p.y - .15), max(h.p.y, abs(h.p.x) - .05))) * S(.25, .2, S(.4, .3, w1))) * .05 + nh * .001;\n\t}\n\telse {\n\t\tc = vec3(.01 + pow(sat(dot(rd, reflect(ld * vec3(-1, -1, 1), n))), 24.) * .6);\n\t\tspe = vec2(8, 5);\n\t}\n\n\tif (h.id == 9) c *= .4;\n\n\t// Combine into final color.\n\treturn (sat(.1 + .9 * dot(ld, n)) * (.1 + .9 * shadow(p, vec3(6, 3, -10))) * (.3 + .7 * ao) * ao + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y) * strobe(p, abs(c)) * 5.;\n}\n\nvec3 scene(vec3 rd) {\n    vec3 p = vec3(0);\n\tfloat i,\n\t      d = 0.;\n\tHit h;\n\tfor (i = Z0; i < 120.; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tvec3 n = N(p, d),\n\t     col = lights(p, rd, n, h) * exp(d * d * -.002);\n\tif (h.id == 1) {\n\t\t// We hit a reflective surface - Cheat and just reflect sky.\n\t\tn = U(n + (n31(h.p * 44.) - .5) * .05);\n\t\tcol += .015 * sky(reflect(rd, n));\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 36.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 col = scene(U(vec3(uv, 1)));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(max(vec3(0), col), vec3(.45)) * sat(t) * S(34., 33., t), 0);\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    }
  ]
}