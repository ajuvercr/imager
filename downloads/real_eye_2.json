{
  "ver": "0.1",
  "info": {
    "id": "dltGDn",
    "date": "1682268637",
    "viewed": 0,
    "name": "Fork Realistic  silvius 632",
    "username": "silvius",
    "description": "Eyeball R&D for Blitz Games Studios (which, sadly, closed today, hence me sharing this).\nLoosely based on Jorge Jimenez's Siggraph 2012 paper.",
    "likes": 0,
    "published": 3,
    "flags": 16,
    "tags": [
      "raytracing",
      "raymarching",
      "subsurfacescattering",
      "eye"
    ],
    "hasliked": 0,
    "usePreview": 0
  },
  "renderpass": [
    {
      "inputs": [
        {
          "id": 30,
          "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
          "ctype": "texture",
          "channel": 0,
          "sampler": {
            "filter": "mipmap",
            "wrap": "repeat",
            "vflip": "false",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        },
        {
          "id": 33,
          "src": "/presets/tex00.jpg",
          "ctype": "keyboard",
          "channel": 3,
          "sampler": {
            "filter": "nearest",
            "wrap": "clamp",
            "vflip": "false",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [],
      "code": "// Hazel Quantock - 15/08/2013\n\n/*\nEye ball effects:\n- Ray-marched shape\n- Ray-traced iris refraction\n- Fake photon mapping on iris\n- Subsurface scattering on sclera\n- HDR reflections with fresnel\n- Eyelid reflection occlusion\n- Eyelid ambient occlusion\n- Procedural textures\n- Procedural animation\n*/\n\n// KEY CONTROLS - (click on eye to give keyboard focus)\nconst int Key_M = 77; // mouse controls camera / eye direction\n\nconst int Key_E = 69; // refraction on/off\nconst int Key_P = 80; // photon mapping on/off\nconst int Key_L = 76; // change photon mapping technique (both fake, but one is imitating reality and the other is prettier)\n\nconst int Key_S = 83; // subsurface scattering on/off\nconst int Key_A = 65; // ambient occlusion on/off\n\nconst int Key_R = 82; // reflection on/off\nconst int Key_O = 79; // reflection eyelid occlusion on/off\n\nconst int Key_C = 67; // iris colour\nconst int Key_N = 78; // iris normal\n\n\n// Lights\n#if (1)\n\t// High-contrast light edge-on\n\tconst vec3 lightDir = vec3(-2,2,.5);\n\tconst vec3 lightColour = vec3(1.0);\n\tconst vec3 fillLightDir = vec3(0,1,0);\n\tconst vec3 fillLightColour = vec3(.65,.7,.8)*.7;//vec3(.15,.2,.25);\n#else\n\t// more neutral \"good\" lighting (doesn't show off the effects)\n\tconst vec3 lightDir = vec3(-2,2,-1);\n\tconst vec3 lightColour = vec3(.83,.8,.78);\n\tconst vec3 fillLightDir = vec3(0,1,0);\n\tconst vec3 fillLightColour = vec3(.65,.7,.8);\n#endif\n\n\n\n// Constants\nconst float tau = 6.28318530717958647692;\n\n// Forward declarations\nfloat Noise( in vec3 x );\nvec2 Noise2( in vec3 x );\n\n\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\n// ------- EDIT THESE THINGS! -------\n\n// Camera (also rotated by mouse)\nconst vec3 CamPos = vec3(0,0.0,-250.0);\nconst vec3 CamLook = vec3(0,0,0);\nconst float CamZoom = 10.0;\nconst float NearPlane = 0.0; // actually not needed\nconst float drawDistance = 1000.0;\n\nconst vec3 SkyColour = vec3(.4,.25,.2);//fillLightColour*.5;//vec3(.1,.3,.5);\n\nvec3 SkyDome( vec3 rd )\n{\n\t//the cube maps have lines in, and aren't HDR, so make our own shapes\n\t\n\t// random variation\n\tvec3 result = ToLinear(SkyColour)*2.0*Noise(rd);\n\t\n\t// square sky-light\n\tresult = mix( result, vec3(8), smoothstep(.8,1.0,rd.y/max((rd.x+1.0),abs(rd.z))) );\n\n\treturn result;\n}\n\n// Eye params\nconst float IrisAng = tau/12.0;\nconst float PupilAng = (1.6*IrisAng/5.0);\nconst float EyeRadius = 10.0;\nconst float BulgeRadius = 6.0; // used for photon trace, must be bigger than EyeRadius*sin(IrisAng)\n\n\nvec4 ComputeEyeRotation()\n{\n\tvec2 rot;\n\tif ( !ReadKey( Key_M, true ) && iMouse.w > .00001 )\n\t\trot = .25*vec2(1.0,1.0)*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x;\n\telse\n\t{\n\t\tfloat time = iTime/2.0;\n\t\ttime += Noise(vec3(0,time,0)); // add noise to time (this adds SO MUCH character!)\n\t\tfloat flick = floor(time)+smoothstep(0.0,0.05,fract(time));\n\t\trot = vec2(.2,.1)*tau*(texture( iChannel0, vec2((flick+.5)/256.0,.5), -100.0 ).rb-.5);\n\t}\n\t\n\treturn vec4(cos(rot.x),sin(rot.x),cos(rot.y),sin(rot.y));\n}\n\n\nvec3 ApplyEyeRotation( vec3 pos, vec4 rotation )\n{\n\tpos.yz = rotation.z*pos.yz + rotation.w*pos.zy*vec2(1,-1);\n\tpos.xz = rotation.x*pos.xz + rotation.y*pos.zx*vec2(1,-1);\n\t\n\treturn pos;\n}\n\t\n\n\n// Shape\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nfloat Isosurface( vec3 pos, vec4 eyeRotation )\n{\n\tpos = ApplyEyeRotation(pos,eyeRotation);\n\t\n/*\tfloat f = length(pos)-EyeRadius;\n\t\n//\tf += Noise(pos*3.0)*.008;\n\n\t// cornea bulge\n\tfloat o = EyeRadius*cos(IrisAng)-sqrt(BulgeRadius*BulgeRadius-EyeRadius*EyeRadius*pow(sin(IrisAng),2.0));\n\tfloat g = length(pos-vec3(0,0,-o))-BulgeRadius;\n\n//g += Noise(pos/2.0)*.5;\n\n\treturn min(f,g);\n\t//return -log(exp(-g*2.0)+exp(-f*2.0))/2.0;*/\n\t\n\tvec2 slice = vec2(length(pos.xy),pos.z);\n\t\n\tfloat aa = atan(slice.x,-slice.y);\n\tfloat bulge = cos(tau*.2*aa/IrisAng);\n\tbulge = bulge*.8-.8;\n\tbulge *= smoothstep(tau*.25,0.0,aa);\n\t\n\t// sharp-edged bulge\n//\tif ( aa < IrisAng )\n//\t\tbulge += cos(tau*.25*aa/IrisAng)*.5;\n\tbulge += cos(tau*.25*aa/IrisAng)*.5 * smoothstep(-.02,.1,IrisAng-aa); // slightly softer\n\t\n\treturn length(slice) - EyeRadius - bulge;\n}\n\n\n\nfloat GetEyelidMask( vec3 pos, vec4 eyeRotation )\n{\n\tvec3 eyelidPos = pos;\n\tfloat eyelidTilt = -.05;\n\teyelidPos.xy = cos(eyelidTilt)*pos.xy + sin(eyelidTilt)*pos.yx*vec2(1,-1);\n\t\n\tfloat highLid = tan(max(tau*.05,asin(eyeRotation.w)+IrisAng+.05));\n\tfloat lowLid = tan(tau*.1);\n\t\n\tfloat blink = smoothstep(.0,.02,abs(Noise(vec3(iTime*.2,0,0))-.5 ));\n\thighLid *= blink;\n\tlowLid *= blink;\n\t\n\treturn min(\n\t\t\t\t(-eyelidPos.z-2.0) - (-eyelidPos.y/lowLid),\n\t\t\t\t(-eyelidPos.z-2.0) - (eyelidPos.y/highLid)\n\t\t\t);\n}\n\t\nfloat GetIrisPattern( vec2 uv )\n{\n\treturn Noise( vec3( 10.0*uv/pow(length(uv),.7), 0 ) );\n}\n\n// Colour\nvec3 Shading( vec3 worldPos, vec3 norm, float shadow, vec3 rd, vec4 eyeRotation )\n{\n\tvec3 view = normalize(-rd);\n\n\t// eyelids - just match BG colour\n\tfloat eyelidMask = GetEyelidMask(worldPos, eyeRotation);\n\t\n\tif ( eyelidMask < 0.0 || (-worldPos.z-3.0) < (worldPos.x/tan(tau*.23)) )\n\t{\n\t\treturn ToLinear(SkyColour);\n\t}\n\t\n\tvec3 pos = ApplyEyeRotation(worldPos,eyeRotation);\n\t\n\tfloat lenposxy = length(pos.xy);\n\tfloat ang = atan(lenposxy/(-pos.z));\n\tif ( ang < 0.0 )\n\t\tang += tau/2.0;\n\t\n\n\t// refract ray\n\tvec3 irisRay = ApplyEyeRotation(-view,eyeRotation);\n\tvec3 localNorm = ApplyEyeRotation(norm,eyeRotation);\n\tfloat a = dot(irisRay,localNorm);\n\tfloat b = cos(acos(a)*1.33);\n\tif ( !ReadKey( Key_E, true ) )\n\t\tirisRay += localNorm*(b-a);\n\tirisRay = normalize(irisRay);\n\t\n\t// intersect with plane\n\tfloat planeDist = -cos(IrisAng)*EyeRadius;\n\tfloat t = (planeDist-pos.z)/irisRay.z;\n\n\tvec3 ppos = t*irisRay+pos;\n\n\n\t// polar coord map\n\tfloat rad = length(ppos.xy);\n\tfloat pupilr = EyeRadius*sin(PupilAng);\n\tfloat irisr = EyeRadius*sin(IrisAng);\n\t\n\tfloat irisPattern = GetIrisPattern(ppos.xy); // reduce contrast of this now we have actual lighting!\n\n/*\tvec3 iris = mix( mix( vec3(.3,.1,.1)*.5+.5*vec3(.6,.4,.1), vec3(.6,.4,.1), irisPattern ), // hazel\n\t\t\t\t\tmix( vec3(.2,.2,.2)*.5+.5*vec3(.5,.45,.2), vec3(.5,.45,.2), irisPattern ),*/\n\n/*\tvec3 iris = mix( mix( vec3(.1,.1,.4), vec3(.7,.9,1), irisPattern ), // blue\n\t\t\t\t\tmix( vec3(.1,.1,.4), vec3(.3,.4,.7), irisPattern ),*/\n\n//\t\t\t\t\tsmoothstep(pupilr*2.0,irisr,rad));\n\n\tvec3 iris = ToLinear( mix( pow( vec3(.65,.82,.85), 2.0*vec3(1.2-sqrt(irisPattern)) ),\n\t\t\t\t\tvec3(1,.5,.2), .7*pow( mix( smoothstep(pupilr,irisr,rad), Noise(ppos), .7), 2.0) ));\n\n\tif ( ReadKey( Key_C, true ) )\n\t\tiris = vec3(1);\n\n\t// darken outer\n\tiris *= pow( smoothstep( irisr+1.0, irisr-1.5, rad ), GAMMA );\n\n\n\tvec3 irisNorm;\n\tirisNorm.x = GetIrisPattern(ppos.xy+vec2(-.001,0)) - GetIrisPattern(ppos.xy+vec2(.001,0));\n\tirisNorm.y = GetIrisPattern(ppos.xy+vec2(0,-.001)) - GetIrisPattern(ppos.xy+vec2(0,.001));\n\n\t// add a radial lump\n\tirisNorm.xy += -.01*normalize(ppos.xy)*sin(1.*tau*rad/irisr);\n\n\tirisNorm.z = -.15; // adjust severity of bumps\n\tirisNorm = normalize(irisNorm);\n\n\tif ( ReadKey( Key_N, true ) )\n\t\tirisNorm = vec3(0,0,-1);\n\t\t\n\n\t// lighting\n\t// fake photon mapping by crudely sampling the photon density\n\n\t// apply lighting with this modified normal\n\tvec3 lightDirN = normalize(lightDir);\n\tvec3 localLightDir = ApplyEyeRotation(lightDirN,eyeRotation);\n\n\tvec3 fillLightDirN = normalize(fillLightDir);\n\tvec3 localFillLightDir = ApplyEyeRotation(fillLightDirN,eyeRotation);\n\n\t// Bend the light, imitating results of offline photon-mapping\n\t// Jimenez's paper makes this seem very complex, because their mapping used a non-flat receiver\n\t// but the self-shadowing was negligible, so the main effect was just like premultiplying by a normal\n\t// where we'd get better results by using the actual normal.\n\n\tfloat photonsL, photonsFL;\n\n\tif ( !ReadKey( Key_P, true ) )\n\t{\n\t\tif ( !ReadKey( Key_L, true ) )\n\t\t{\n\t\t\t// Nice retro-reflective effect, but not correct\n\t\t\tvec3 nn = normalize(vec3( ppos.xy, -sqrt(max(0.0,BulgeRadius*BulgeRadius-rad*rad)) ));\n\t\t\t\n\t\t\tvec3 irisLDir = localLightDir;\n\t\t\tvec3 irisFLDir = localFillLightDir;\n\t\t//\tirisLDir.z = -cos(acos(-irisLDir.z)/1.33); // experiments showed it cuts out at 120 degrees, i.e. 1.33*the usual 90 degree cutoff\n\t\t//\tirisFLDir.z = -cos(acos(-irisFLDir.z)/1.33); // experiments showed it cuts out at 120 degrees, i.e. 1.33*the usual 90 degree cutoff\n\t\t\tfloat d = dot(nn,irisLDir);\n\t\t\tirisLDir += nn*(cos(acos(d)/1.33) - d);\n\t\t\td = dot(nn,irisFLDir);\n\t\t\tirisFLDir += nn*(cos(acos(d)/1.33) - d);\n\t\t\tirisLDir = normalize(irisLDir);\n\t\t\tirisFLDir = normalize(irisFLDir);\n\t\t\tphotonsL = smoothstep(0.0,1.0,dot(irisNorm,irisLDir)); //soften terminator\n\t\t\tphotonsFL = (dot(irisNorm,irisFLDir)*.5+.5);\n\t\t\t//Seriously, this^ looks really nice, but not like reality. Bah!\n\t\t\n\t\t/* reverse it, to make it look a lot like the accurate version - meh\n\t\t\tvec3 nn = normalize(vec3( -ppos.xy, -sqrt(max(0.0,BulgeRadius*BulgeRadius-rad*rad)) ));\n\t\t\t\n\t\t\tvec3 irisLDir = localLightDir;\n\t\t\tvec3 irisFLDir = localFillLightDir;\n\t\t\tfloat d = dot(nn,irisLDir);\n\t\t\tirisLDir += nn*(cos(acos(d)/1.33) - d);\n\t\t\td = dot(nn,irisFLDir);\n\t\t\tirisFLDir += nn*(cos(acos(d)/1.33) - d);\n\t\t\tirisLDir = normalize(irisLDir);\n\t\t\tirisFLDir = normalize(irisFLDir);\n\t\t\t\n\t\t\tfloat photonsL = smoothstep(0.0,1.0,dot(irisNorm,irisLDir)); // soften the terminator\n\t\t\tfloat photonsFL = (dot(irisNorm,irisFLDir)*.5+.5);\n\t\t*/\n\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//this is a reasonable match to the dark crescent effect seen in photos and offline photon mapping, but it looks wrong to me.\n\t\t\tvec3 irisLDir = localLightDir;\n\t\t\tvec3 irisFLDir = localFillLightDir;\n\t\t\tirisLDir.z = -cos(acos(-irisLDir.z)/1.5); // experiments showed it cuts out at 120 degrees, i.e. 1.33*the usual 90 degree cutoff\n\t\t\tirisFLDir.z = -cos(acos(-irisFLDir.z)/1.5); // experiments showed it cuts out at 120 degrees, i.e. 1.33*the usual 90 degree cutoff\n\t\t\tirisLDir = normalize(irisLDir);\n\t\t\tirisFLDir = normalize(irisFLDir);\n\t\t\n\t\t\tphotonsL = smoothstep(0.0,1.0,dot(irisNorm,irisLDir)); // soften the terminator\n\t\t\tphotonsFL = (dot(irisNorm,irisFLDir)*.5+.5);\n\t\t\n\t\t\t// dark caustic ring\n\t\t\tphotonsL *= .3+.7*smoothstep( 1.2, .9, length(ppos.xy/irisr+.2*irisLDir.xy/(irisLDir.z-.05)) );\n\t\t//\tphotonsFL *= ...;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// no photons\n\t\tphotonsL = max( 0.0, dot(irisNorm,localLightDir) ); \n\t\tphotonsFL = .5+.5*dot(irisNorm,localLightDir); \n\t}\n\t\t\n\tvec3 l = ToLinear(lightColour)*photonsL;\n\tvec3 fl = ToLinear(fillLightColour)*photonsFL;\n\n\tvec3 ambientOcclusion = vec3(1);\n\tvec3 eyelidShadow = vec3(1);\n\tif ( !ReadKey( Key_A, true ) )\n\t{\n\t\t// ambient occlusion on fill light\n\t\tambientOcclusion = mix( vec3(1), ToLinear(vec3(.8,.7,.68)), pow(smoothstep( 5.0, 0.0, eyelidMask ),1.0) );\n\t\t\n\t\t// shadow on actual light\n\t\teyelidShadow = mix( vec3(1), ToLinear(vec3(.8,.7,.68)), smoothstep( 2.0, -2.0, GetEyelidMask( worldPos+lightDir*1.0, eyeRotation ) ) );\n\t}\n\tfl *= ambientOcclusion;\n\tl *= eyelidShadow;\n\t\n\tiris *= l+fl;\n\n\t// darken pupil\n\tiris *= smoothstep( pupilr-.01, pupilr+.5, rad );\n\n\n\t// veins\n\tfloat theta = atan(pos.x,pos.y);\n\ttheta += Noise(pos*1.0)*tau*.03;\n\tfloat veins = (sin(theta*60.0)*.5+.5);\n\tveins *= veins;\n\tveins *= (sin(theta*13.0)*.5+.5);\n\tveins *= smoothstep( IrisAng, tau*.2, ang );\n\tveins *= veins;\n\tveins *= .5;\n\t\n\tvec3 sclera = mix( ToLinear(vec3(1,.98,.96)), ToLinear(vec3(.9,.1,0)), veins );\n\n\tfloat ndotl = dot(norm,lightDirN);\n\t\n\t// subsurface scattering\n//\tfloat subsurface = max(0.0,-2.0*ndotl*EyeRadius);\n//\tl = pow(ToLinear(vec3(.5,.3,.25)),vec3(subsurface*.2)); // more intense the further light had to travel\n\n\t// fake, because that^ approximation gives a hard terminator\n\tl = pow(ToLinear(vec3(.5,.3,.25)), vec3(mix( 3.0, 0.0, smoothstep(-1.0,.2,ndotl) )) );\n\t\n\tif ( ReadKey( Key_S, true ) )\n//\t\tl = mix( l, vec3(max(0.0,ndotl)), 0.5 );\n//\telse\n\t\tl = vec3(max(0.0,ndotl));\n\n\tl *= ToLinear(lightColour);\n\t\n\tfl = ToLinear(fillLightColour)*(dot(norm,fillLightDirN)*.5+.5);\n\n\tfl *= ambientOcclusion;\n\tl *= eyelidShadow;\n\t\n\t\n\tsclera *= l+fl;\n\n\t// blend between them\n\tfloat blend = smoothstep(-.1,.1,ang-IrisAng);\n\tvec3 result = mix(iris,sclera,blend);\n\n\t\n\t// eyelid ambient occlusion/radiosity\n//\tif ( !ReadKey( Key_A, true ) )\n\t\t//result *= mix( vec3(1), ToLinear(vec3(.65,.55,.55)), exp2(-eyelidMask*2.0) );\n//\t\tresult *= mix( vec3(1), ToLinear(vec3(.8,.7,.68)), pow(smoothstep( 5.0, 0.0, eyelidMask ),1.0) );\n\t\n\t\n\t// bumps - in specular only to help sub-surface scattering look smooth\n\tvec3 bumps;\n\tbumps.xy = .7*Noise2( pos*3.0 );\n\tbumps.z = sqrt(1.0-dot(bumps.xy,bumps.xy));\n\n\tbumps = mix( vec3(0,0,1), bumps, blend );\n\t\n\tnorm.xy += bumps.xy*.1;\n\tnorm = normalize(norm);\n\t\n\tfloat glossiness = mix(.7,1.0,bumps.z);\n\t\n\t// reflection map\n\tfloat ndoti = dot( view, norm );\n\tvec3 rr = -view+2.0*ndoti*norm;\n\tvec3 reflection = SkyDome( rr );\n\t\n\t// specular\n\tvec3 h = normalize(view+lightDir);\n\tfloat specular = pow(max(0.0,dot(h,norm)),2000.0);\n\n\t// should fresnel affect specular? or should it just be added?\n\treflection += specular*32.0*glossiness*ToLinear(lightColour);\n\n\t// reflection of eyelids\n\t//float eyelidReflection = smoothstep( 1.8, 2.0, eyelidMask );\n\t// apply some parallax (subtle improvement when looking up/down at eye)\n\tfloat eyelidReflection = smoothstep( .8, 1.0, GetEyelidMask( normalize(worldPos + rd*2.0)*EyeRadius, eyeRotation ) );\n\tif ( !ReadKey( Key_O, true ) )\n\t\treflection *= eyelidReflection;\n\n\t// fresnel\n\tfloat fresnel = mix(.04*glossiness,1.0,pow(1.0-ndoti,5.0));\n\n\tif ( !ReadKey( Key_R, true ) )\n\t\tresult = mix ( result, reflection, fresnel );\n\n\n\t//anti-alias the edge\n\tfloat mask2 = min( eyelidMask, (-worldPos.z-3.0) - (worldPos.x/tan(tau*.23)) );\n\tresult = mix( ToLinear(SkyColour), result, smoothstep(.0,.3,mask2) );\n\t\n\treturn result;\n}\n\n\n// Precision controls\nconst float epsilon = .003;\nconst float normalPrecision = .1;\nconst float shadowOffset = .1;\nconst int traceDepth = 100; // takes time\n\n\n\n// ------- BACK-END CODE -------\n\nvec2 Noise2( in vec3 x )\n{\n    vec3 p = floor(x.xzy);\n    vec3 f = fract(x.xzy);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\t\t\nfloat Noise( in vec3 x )\n{\n\treturn Noise2(x).x;\n}\n\nfloat Trace( vec3 ro, vec3 rd, vec4 eyeRotation )\n{\n\tfloat t = 0.0;\n\tfloat dist = 1.0;\n\tfor ( int i=0; i < traceDepth; i++ )\n\t{\n\t\tif ( abs(dist) < epsilon || t > drawDistance || t < 0.0 )\n\t\t\tcontinue;\n\t\tdist = Isosurface( ro+rd*t, eyeRotation );\n\t\tt = t+dist;\n\t}\n\t\n\treturn t;//vec4(ro+rd*t,dist);\n}\n\n// get normal\nvec3 GetNormal( vec3 pos, vec4 eyeRotation )\n{\n\tconst vec2 delta = vec2(normalPrecision, 0);\n\t\n\tvec3 n;\n\n// it's important this is centred on the pos, it fixes a lot of errors\n\tn.x = Isosurface( pos + delta.xyy, eyeRotation ) - Isosurface( pos - delta.xyy, eyeRotation );\n\tn.y = Isosurface( pos + delta.yxy, eyeRotation ) - Isosurface( pos - delta.yxy, eyeRotation );\n\tn.z = Isosurface( pos + delta.yyx, eyeRotation ) - Isosurface( pos - delta.yyx, eyeRotation );\n\treturn normalize(n);\n}\t\t\t\t\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay( vec3 dir, float zoom, vec2 uv )\n{\n\tuv = uv - .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn dir + right*uv.x + up*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 camPos = CamPos;\n\tvec3 camLook = CamLook;\n\n\tvec2 camRot = .5*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x;\n\tif ( !ReadKey( Key_M, true ) )\n\t\tcamRot = vec2(0,0);\n\tcamPos.yz = cos(camRot.y)*camPos.yz + sin(camRot.y)*camPos.zy*vec2(1,-1);\n\tcamPos.xz = cos(camRot.x)*camPos.xz + sin(camRot.x)*camPos.zx*vec2(1,-1);\n\t\n\tvec4 eyeRotation = ComputeEyeRotation();\n\t\n\tif ( Isosurface(camPos, eyeRotation) <= 0.0 )\n\t{\n\t\t// camera inside ground\n\t\tfragColor = vec4(0,0,0,0);\n\t\treturn;\n\t}\n\n\tvec3 ro = camPos;\n\tvec3 rd;\n\trd = GetRay( camLook-camPos, CamZoom, uv );\n\t\n\tro += rd*(NearPlane/CamZoom);\n\t\n\trd = normalize(rd);\n\t\n\tfloat t = Trace(ro,rd,eyeRotation);\n\n\tvec3 result = ToLinear(SkyColour);\n\tif ( t > 0.0 && t < drawDistance )\n\t{\n\t\tvec3 pos = ro+t*rd;\n\t\t\t\n\t\tvec3 norm = GetNormal(pos,eyeRotation);\n\t\t\n\t\t// shadow test\n\t\tfloat shadow = 1.0;\n\t\tif ( Trace( pos+lightDir*shadowOffset, lightDir, eyeRotation ) < drawDistance )\n\t\t\tshadow = 0.0;\n\t\t\n\t\tresult = Shading( pos, norm, shadow, rd, eyeRotation );\n\t\t\n\t\t// fog\n//\t\tresult = mix ( SkyColour, result, exp(-t*t*.0002) );\n\t}\n\n\tfragColor = vec4( ToGamma( result ), 1.0 );\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    }
  ]
}
