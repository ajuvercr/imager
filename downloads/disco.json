{
  "ver": "0.1",
  "info": {
    "id": "mlc3D7",
    "date": "1682534329",
    "viewed": 0,
    "name": "Fork The Popula silvius 320",
    "username": "silvius",
    "description": "I remade my other shader (https://www.shadertoy.com/view/ldjGWD) inspired by \"The Popular Demo\", to make it more accurate :)\nI added a tiling effect to make the robot look faceted, but it seems to somehow over-complicate the shader so it doesn't compile.",
    "likes": 0,
    "published": 3,
    "flags": 0,
    "tags": [
      "procedural",
      "raytracing",
      "raymarching",
      "disco",
      "popular"
    ],
    "hasliked": 0,
    "usePreview": 0
  },
  "renderpass": [
    {
      "inputs": [],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "#define USE_IQ_SMIN 0\n\nfloat time;\n\nvec2 leg0[3];\nvec2 leg1[3];\n\nvec2 arm0[3];\nvec2 arm1[3];\n\nfloat wlen=15.0;\nfloat bob;\nfloat wc_scale=0.5;\nfloat scroll;\nfloat scene_scale=15.0;\n\n// Finds the entry and exit points of a 2D ray with a circle of radius 1\n// centered at the origin.\nvec2 intersectCircle(vec2 ro, vec2 rd)\n{\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, ro);\n\tfloat ds = b * b - 4.0 * a * (dot(ro, ro) - 1.0);\n\t\n\tif(ds < 0.0)\n\t\treturn vec2(1e3);\n\t\n\treturn ((-b - sqrt(ds) * vec2(-1.0, 1.0))) / (2.0 * a);\n}\n\nmat3 rotateXMat(float a)\n{\n\treturn mat3(1.0, 0.0, 0.0, 0.0, cos(a), -sin(a), 0.0, sin(a), cos(a));\n}\n\nmat3 rotateYMat(float a)\n{\n\treturn mat3(cos(a), 0.0, -sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a));\n}\n\n// Adapted from https://www.shadertoy.com/view/ldlGR7   \nvec2 solve( vec2 p, float l1, float l2, float side )\n{\n\tvec2 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1/dot(q,q) - 1.0;\n\t\n\tif( s<0.0 ) return vec2(-100.0);\n\t\n\treturn q + q.yx*vec2(-1.0,1.0)*side*sqrt( s );\n}\n\n// Returns a pyramid-like periodic signal.\nfloat pyramid(float x)\n{\n\tx = fract(x);\n\treturn min(x * 2.0, (1.0 - x) * 2.0);\n}\n\n// Returns a semicircular periodic signal.\nfloat circ(float x)\n{\n\tx = fract(x) * 2.0 - 1.0;\n\treturn sqrt(1.0 - x * x);\n}\n\n#if USE_IQ_SMIN\nfloat smin(float a,float b,float k){ return -log(exp(-k*a)+exp(-k*b))/k;}//from iq\n#else\n// http://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\nfloat smin(in float a, in float b, in float k) { return a - log(1.0+exp(k*(a-b))) / k; }\n#endif\n\nfloat mp(float x)\n{\n\tfloat y=0.3;\n\treturn clamp((pyramid(x)-0.5)*2.0-0.4,-y,y);\n}\n\nfloat mosaic(vec3 p)\n{\n\t// Disabled because it causes a compilation failure due to time-out or size limit.\n\treturn 0.0;//max(mp(p.y*10.0),mp(p.z*10.0))*0.01;\n}\n/*\nmat3 transpose(mat3 m)\n{\n\treturn mat3(vec3(m[0].x,m[1].x,m[2].x),\n\t\t\t\tvec3(m[0].y,m[1].y,m[2].y),\n\t\t\t\tvec3(m[0].z,m[1].z,m[2].z));\n}*/\n\nfloat capsuleDist(vec3 p,vec3 o,vec3 d,float h0,float h1,float r0,float r1)\n{\n\tvec3 u=cross(d,vec3(1.0,0.0,0.0));\n\tvec3 v=cross(u,d);\n\tu=cross(v,d);\n\tmat3 m=transpose(mat3(normalize(u),normalize(v),normalize(d)));\n\td=normalize(d);\n\tfloat t=clamp(dot(p-o,d),h0,h1);\n\tvec3 np=o+t*d;\n\treturn distance(np,p)-mix(r0,r1,t)+mosaic(m*(p-o));\n}\n\nfloat boxDist(vec3 p,vec3 s,float r)\n{\n\treturn length(max(vec3(0.0),abs(p)-s))-r+mosaic(p);\n}\n\nfloat sphereDist(vec3 p,vec3 o,float r)\n{\n\treturn distance(p,o)-r+mosaic(p-o);\n}\n\nfloat sceneDist(vec3 p)\n{\n\tfloat d=1e3;\n\t\n\tp+=vec3(0.0,0.07,0.0)*scene_scale;\n\tp=rotateYMat(3.1415926*0.5)*p;\n\t\n\tp.z+=cos(p.y*2.0+time)*0.1;\n\tfloat tm=fract(time*wc_scale*2.0-0.1);\n\tp.x-=(smoothstep(0.0,0.3,tm)-smoothstep(0.4,1.0,tm))*smoothstep(0.5,2.0,p.y)*0.2+scroll;\n\t\n\t// Leg 0\n\t{\n\t\tfloat g=0.08;\n\t\tvec3 o=vec3(0.0,0.0,0.2);\n\t\tfloat d0=capsuleDist(p+o,vec3(leg0[0],0.0),vec3(leg0[1]-leg0[0],0.0),0.0,1.0-g,0.1,0.1);\n\t\tfloat d1=capsuleDist(p+o,vec3(leg0[1],0.0),vec3(leg0[2]-leg0[1],0.0),g,1.0,0.1,0.2);\n\t\td=min(d,smin(d0,d1,15.0));\n\t}\n\t\n\t// Leg 1\n\t{\n\t\tfloat g=0.08;\n\t\tvec3 o=vec3(0.0,0.0,-0.2);\n\t\tfloat d0=capsuleDist(p+o,vec3(leg1[0],0.0),vec3(leg1[1]-leg1[0],0.0),0.0,1.0-g,0.1,0.1);\n\t\tfloat d1=capsuleDist(p+o,vec3(leg1[1],0.0),vec3(leg1[2]-leg1[1],0.0),g,1.0,0.1,0.2);\n\t\td=min(d,smin(d0,d1,15.0));\n\t}\n\t\n\tp.y-=bob;\n\t\n\t// Arm 0\n\t{\n\t\tfloat g=0.08;\n\t\tvec3 o=vec3(0.0,0.0,0.4);\n\t\tmat3 m=rotateXMat(-0.3)*rotateYMat((cos((time*wc_scale+0.5)*3.1415926*2.0)-0.6)*0.5);\n\t\tfloat d0=capsuleDist(p+o,vec3(arm0[0],0.0),m*vec3(arm0[1]-arm0[0],0.0),0.0,0.7-g,0.03,0.03);\n\t\tfloat d1=capsuleDist(p+o,vec3(arm0[0],0.0)+m*vec3(arm0[1]-arm0[0],0.0),m*vec3(arm0[2]-arm0[1],0.0),g,0.7,0.03,0.06);\n\t\td=min(d,smin(d0,d1,15.0));\n\t}\n\t\n\t// Arm 1\n\t{\n\t\tfloat g=0.08;\n\t\tvec3 o=vec3(0.0,0.0,-0.4);\n\t\tmat3 m=rotateXMat(0.3)*rotateYMat(-(cos(time*wc_scale*3.1415926*2.0)-0.6)*0.5);\n\t\tfloat d0=capsuleDist(p+o,vec3(arm1[0],0.0),m*vec3(arm1[1]-arm1[0],0.0),0.0,0.7-g,0.03,0.03);\n\t\tfloat d1=capsuleDist(p+o,vec3(arm1[0],0.0)+m*vec3(arm1[1]-arm1[0],0.0),m*vec3(arm1[2]-arm1[1],0.0),g,0.7,0.03,0.06);\n\t\td=min(d,smin(d0,d1,15.0));\n\t}\n\t\n\t// Torso   \n\td=smin(d,boxDist(p+vec3(0.0,-0.7,0.0),vec3(0.05,0.7,0.15),0.1),15.0);\n\td=smin(d,boxDist(p+vec3(-0.1,-1.1,0.0),vec3(0.05,0.2,0.15)*0.1,0.1),5.0);\n\t\n\t// Head\n\td=smin(d,sphereDist(p,vec3(0.0,1.825,0.0),0.2),15.0);\n\t\n\t\n\treturn d;\n}\n\nvec3 sceneNorm(vec3 p)\n{\n\tp*=scene_scale;\n\tfloat c=sceneDist(p);\n\tfloat e=1e-3;\n\treturn normalize(vec3(sceneDist(p+vec3(e,0,0))-c,\n\t\t\t\t\t\t  sceneDist(p+vec3(0,e,0))-c,\n\t\t\t\t\t\t  sceneDist(p+vec3(0,0,e))-c));\n}\n\nfloat robot(vec3 ro,vec3 rd)\n{\n\tfloat t=0.0;\n\tfloat tm;\n\t\n\ttm=time*wc_scale;\n\t\n\tleg0[0]=vec2(0.0,bob);\n\tleg0[2]=vec2(pyramid(tm)-0.3,-1.8+0.3*circ(tm*2.0)*step(fract(tm),0.5));\n\tleg0[1]=(leg0[0]+solve(leg0[2]-leg0[0],1.0,1.0,1.0));\n\t\n\tarm1[0]=vec2(0.0,1.4);\n\tarm1[2]=vec2(pyramid(tm)-0.3,0.1+pow(pyramid(tm),2.0)*0.7);\n\tarm1[1]=(arm1[0]+solve(arm1[2]-arm1[0],0.7,0.7,-1.0));\n\t\n\ttm+=0.5;\n\t\n\tleg1[0]=vec2(0.0,bob);\n\tleg1[2]=vec2(pyramid(tm)-0.3,-1.8+0.3*circ(tm*2.0)*step(fract(tm),0.5));\n\tleg1[1]=(leg1[0]+solve(leg1[2]-leg1[0],1.0,1.0,1.0));\n\t\n\tarm0[0]=vec2(0.0,1.4);\n\tarm0[2]=vec2(pyramid(tm)-0.3,0.1+pow(pyramid(tm),2.0)*0.7);\n\tarm0[1]=(arm0[0]+solve(arm0[2]-arm0[0],0.7,0.7,-1.0));\n\t\n\tfloat rt=1e4;\n\t\n\tro*=scene_scale;\n\trd*=scene_scale;\n\t\n\tfor(int i=0;i<15;i+=1)\n\t{\n\t\tvec3 rp=ro+rd*t;\n\t\t\n\t\tfloat d=sceneDist(rp);\n\t\t\n\t\tif(d<1e-2)\n\t\t{\n\t\t\trt=t;\n\t\t}\n\t\t\n\t\tt+=d/scene_scale;\n\t}\n\t\n\t\n\treturn rt;\n}\n\n\nvec2 unitSquareInterval(vec2 ro, vec2 rd)\n{\t\n\tvec2 slabs0 = (vec2(+1.0) - ro) / rd;\t\n\tvec2 slabs1 = (vec2(-1.0) - ro) / rd;\n\t\n\tvec2 mins = min(slabs0, slabs1);\n\tvec2 maxs = max(slabs0, slabs1);\n\t\n\treturn vec2(max(mins.x, mins.y),\n\t\t\t\tmin(maxs.x, maxs.y));\n}\n\nvec3 squaresColours(vec2 p)\n{\n\tp+=vec2(time*0.2);\n\t\n\tvec3 orange=vec3(1.0,0.4,0.1)*2.0;\n\tvec3 purple=vec3(1.0,0.2,0.5)*0.8;\n\t\n\tfloat l=pow(0.5+0.5*cos(p.x*7.0+cos(p.y)*8.0)*sin(p.y*2.0),4.0)*2.0;\n\tvec3 c=pow(l*(mix(orange,purple,0.5+0.5*cos(p.x*40.0+sin(p.y*10.0)*3.0))+\n\t\t\t\t  mix(orange,purple,0.5+0.5*cos(p.x*20.0+sin(p.y*3.0)*3.0))),vec3(1.2))*0.7;\n\t\n\tc+=vec3(1.0,0.8,0.4)*pow(0.5+0.5*cos(p.x*20.0)*sin(p.y*12.0),20.0)*2.0;\n\t\n\tc+=vec3(0.1,0.5+0.5*cos(p*20.0))*vec3(0.05,0.1,0.4).bgr*0.7;\n\t\n\treturn c;\n}\n\nvec3 squaresTex(vec2 p,float border)\n{\n\tfloat sm=0.02;\n\tvec2 res=vec2(8.0);\n\tvec2 ip=floor(p*res)/res;\n\tvec2 fp=fract(p*res);\n\tfloat m=1.0-max(smoothstep(border-sm,border,abs(fp.x-0.5)),smoothstep(border-sm,border,abs(fp.y-0.5)));\n\tm+=1.0-smoothstep(0.0,0.56,distance(fp,vec2(0.5)));\n\treturn m*squaresColours(ip);\n}\n\nvec3 room(vec3 ro,vec3 rd,out vec3 rp,out vec3 n)\n{\n\tvec2 box_size=vec2(1.0,5.0+3.0/8.0);\n\t\n\tvec2 cp=vec2(0.0),ct=vec2(1e3);\n\t\n\tfor(int i=0;i<4;i+=1)\n\t{\n\t\tfloat cr=0.03;\n\t\tvec2 tcp=vec2(2.5/8.0*float(-1),float(i)-2.0+0.5/8.0);\n\t\tvec2 tct=intersectCircle((ro.xz-tcp)/cr,rd.xz/cr);\n\t\t\n\t\tif(tct.y > 0.0 && tct.y<ct.y)\n\t\t{\n\t\t\tct=tct;\n\t\t\tcp=tcp;\n\t\t}\n\t}\n\n\tfor(int i=0;i<4;i+=1)\n\t{\n\t\tfloat cr=0.03;\n\t\tvec2 tcp=vec2(2.5/8.0*float(+1),float(i)-2.0+0.5/8.0);\n\t\tvec2 tct=intersectCircle((ro.xz-tcp)/cr,rd.xz/cr);\n\t\t\n\t\tif(tct.y > 0.0 && tct.y<ct.y)\n\t\t{\n\t\t\tct=tct;\n\t\t\tcp=tcp;\n\t\t}\n\t}\n\t\n\tct.y=max(0.0,ct.y);\n\t\n\tvec3 ci=ro+rd*ct.y;\n\tvec2 cu=vec2(atan(ci.z-cp.y,ci.x-cp.x)/3.1415926*0.5,(ci.y+0.5/8.0)*4.0);\n\t\n\tfloat wt=max(0.0,unitSquareInterval(ro.xy * box_size, rd.xy * box_size).y);\n\tfloat t=min(ct.y,wt);\n\t\n\trp=ro+rd*(t-1e-4);\n\t\n\tn.z=0.0;\n\tif(abs(rp.x*box_size.x)>abs(rp.y*box_size.y))\n\t\tn.xy=vec2(rp.x/abs(rp.x),0.0);\n\telse\n\t\tn.xy=vec2(0.0,rp.y/abs(rp.y));\n\t\n\tif(ct.y<wt)\n\t{\n\t\tn.y=0.0;\n\t\tn.xz=normalize(rp.xz-ci.xz);\n\t}\n\t\n\tfloat l=1.0-smoothstep(0.0,3.0,abs(rp.z-ro.z));\n\t\n\tvec3 wc=mix(squaresTex(rp.zy+vec2(0.0,0.5/8.0),0.5),squaresTex(rp.xz,0.44),step(0.999/box_size.y,abs(rp.y)));\n\tvec3 cc=squaresTex(cu,0.45)+0.8*vec3(smoothstep(0.83/5.0,0.86/5.0,abs(rp.y)));\n\t\n\treturn l*mix(cc,wc,step(wt,t));\n}\n\nvec3 scene(vec2 p)\n{\n\tmat3 cam = rotateXMat(cos(time * 0.2) * 0.1) * rotateYMat(time * 0.5);\n\tfloat lt=mod(time*wc_scale,wlen)/wlen;\n\t\n\tvec3 ro = cam*vec3(0.0,-0.15+lt*0.15, 0.15+lt*0.2)+vec3(0.0,0.0,scroll/scene_scale);\n\tvec3 rd = cam*vec3(p, -1.0);\n\t\n\trd=normalize(rd);\n\t\n\tfloat robot_t=robot(ro,rd);\n\t\n\tvec3 n,rp;\n\t\n\tvec3 c;\n\tvec3 c0=room(ro,rd,rp,n);\n\t\n\tif(robot_t < distance(ro,rp))\n\t{\n\t\trp=ro+rd*robot_t;\n\t\tn=sceneNorm(rp);\n\t\tvec3 r=reflect(rd,n);\n\t\tc=vec3(0.5+0.5*n.y)*0.5*vec3(1.0,0.8,0.5);\n\t\tvec3 c1=room(rp,r,rp,n);\n\t\tc+=c1*0.5;\n\t}\n\telse\n\t{\n\t\tvec3 r=reflect(rd,n);\n\t\tvec3 c1=room(rp,r,rp,n);\n\t\tc=c0+c1*c0*0.4;\n\t}\n\t\t\n\tvec3 ll=vec3(1.0-(smoothstep(0.0,0.07,lt)-smoothstep(0.93,1.0,lt)));\n\t\n\treturn ll+c+\n\t\t0.6*((sin(p.y)*cos(p.x+time*2.0)*0.5+0.5)*\n\t\t\t pow(mix(vec3(1.0,0.7,0.1),vec3(1.0,0.2,0.6),0.5+0.5*cos(p.x+sin(time*3.0+p.y*2.0))),vec3(2.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime=iTime+1.0;\n\tbob=cos(time*12.0)*0.05;\n\tscroll=-15.0+mod(time*wc_scale,wlen)*2.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q=uv;\n\tvec2 t=uv*2.0-vec2(1.0);\n\tt.x*=iResolution.x/iResolution.y;\n\tfragColor.rgb = scene(t.xy) * 1.3;\n\t\n\t// vignet\n\tfragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n}\n",
      "name": "Image",
      "description": "",
      "type": "image"
    }
  ]
}