{
  "ver": "0.1",
  "info": {
    "id": "Wt33Wf",
    "date": "1580223238",
    "viewed": 272212,
    "name": "Cyber Fuji 2020",
    "username": "kaiware007",
    "description": "A Happy New Yeahhhhhhhhhhhhhhhhhh!!!!!!!!!!!!!",
    "likes": 261,
    "published": 3,
    "flags": 0,
    "tags": [
      "sun",
      "80s",
      "retro",
      "fuji",
      "cineshader"
    ],
    "hasliked": 0,
    "usePreview": 0
  },
  "renderpass": [
    {
      "inputs": [],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "\nfloat sun(vec2 uv, float battery)\n{\n \tfloat val = smoothstep(0.3, 0.29, length(uv));\n \tfloat bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + iTime * 0.2 * (battery + 0.02)) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * (battery + 0.05));\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);\n    return mix(d2, d1 , h) - k * h * ( 1.0 - h);\n}\n\nfloat sdCloud(in vec2 p, in vec2 a1, in vec2 b1, in vec2 a2, in vec2 b2, float w)\n{\n\t//float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));\n    float lineVal1 = sdLine(p, a1, b1);\n    float lineVal2 = sdLine(p, a2, b2);\n    vec2 ww = vec2(w*1.5, 0.0);\n    vec2 left = max(a1 + ww, a2 + ww);\n    vec2 right = min(b1 - ww, b2 - ww);\n    vec2 boxCenter = (left + right) * 0.5;\n    //float boxW = right.x - left.x;\n    float boxH = abs(a2.y - a1.y) * 0.5;\n    //float boxVal = sdBox(p - boxCenter, vec2(boxW, boxH)) + w;\n    float boxVal = sdBox(p - boxCenter, vec2(0.04, boxH)) + w;\n    \n    float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);\n    float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);\n    \n    return min(uniVal1, uniVal2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float battery = 1.0;\n    //if (iMouse.x > 1.0 && iMouse.y > 1.0) battery = iMouse.y / iResolution.y;\n    //else battery = 0.8;\n    \n    //if (abs(uv.x) < (9.0 / 16.0))\n    {\n        // Grid\n        float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n        vec3 col = vec3(0.0, 0.1, 0.2);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv, battery);\n            col = mix(col, vec3(1.0, 0.5, 1.0), gridVal);\n        }\n        else\n        {\n            float fujiD = min(uv.y * 4.5 - 0.5, 1.0);\n            uv.y -= battery * 1.1 - 0.51;\n            \n            vec2 sunUV = uv;\n            vec2 fujiUV = uv;\n            \n            // Sun\n            sunUV += vec2(0.75, 0.2);\n            //uv.y -= 1.1 - 0.51;\n            col = vec3(1.0, 0.2, 1.0);\n            float sunVal = sun(sunUV, battery);\n            \n            col = mix(col, vec3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);\n            col = mix(vec3(0.0, 0.0, 0.0), col, sunVal);\n            \n            // fuji\n            float fujiVal = sdTrapezoid( uv  + vec2(-0.75+sunUV.y * 0.0, 0.5), 1.75 + pow(uv.y * uv.y, 2.1), 0.2, 0.5);\n            float waveVal = uv.y + sin(uv.x * 20.0 + iTime * 2.0) * 0.05 + 0.2;\n            float wave_width = smoothstep(0.0,0.01,(waveVal));\n            \n            // fuji color\n            col = mix( col, mix(vec3(0.0, 0.0, 0.25), vec3(1.0, 0.0, 0.5), fujiD), step(fujiVal, 0.0));\n            // fuji top snow\n            col = mix( col, vec3(1.0, 0.5, 1.0), wave_width * step(fujiVal, 0.0));\n            // fuji outline\n            col = mix( col, vec3(1.0, 0.5, 1.0), 1.0-smoothstep(0.0,0.01,abs(fujiVal)) );\n            //col = mix( col, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(0.03,0.04,abs(fujiVal)) );\n            //col = vec3(1.0, 1.0, 1.0) *(1.0-smoothstep(0.03,0.04,abs(fujiVal)));\n            \n            // horizon color\n            col += mix( col, mix(vec3(1.0, 0.12, 0.8), vec3(0.0, 0.0, 0.2), clamp(uv.y * 3.5 + 3.0, 0.0, 1.0)), step(0.0, fujiVal) );\n            \n            // cloud\n            vec2 cloudUV = uv;\n            cloudUV.x = mod(cloudUV.x + iTime * 0.1, 4.0) - 2.0;\n            float cloudTime = iTime * 0.5;\n            float cloudY = -0.5;\n            float cloudVal1 = sdCloud(cloudUV, \n                                     vec2(0.1 + sin(cloudTime + 140.5)*0.1,cloudY), \n                                     vec2(1.05 + cos(cloudTime * 0.9 - 36.56) * 0.1, cloudY), \n                                     vec2(0.2 + cos(cloudTime * 0.867 + 387.165) * 0.1,0.25+cloudY), \n                                     vec2(0.5 + cos(cloudTime * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);\n            cloudY = -0.6;\n            float cloudVal2 = sdCloud(cloudUV, \n                                     vec2(-0.9 + cos(cloudTime * 1.02 + 541.75) * 0.1,cloudY), \n                                     vec2(-0.5 + sin(cloudTime * 0.9 - 316.56) * 0.1, cloudY), \n                                     vec2(-1.5 + cos(cloudTime * 0.867 + 37.165) * 0.1,0.25+cloudY), \n                                     vec2(-0.6 + sin(cloudTime * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);\n            \n            float cloudVal = min(cloudVal1, cloudVal2);\n            \n            //col = mix(col, vec3(1.0,1.0,0.0), smoothstep(0.0751, 0.075, cloudVal));\n            col = mix(col, vec3(0.0, 0.0, 0.2), 1.0 - smoothstep(0.075 - 0.0001, 0.075, cloudVal));\n            col += vec3(1.0, 1.0, 1.0)*(1.0 - smoothstep(0.0,0.01,abs(cloudVal - 0.075)));\n        }\n\n        col += fog * fog * fog;\n        col = mix(vec3(col.r, col.r, col.r) * 0.5, col, battery * 0.7);\n\n        fragColor = vec4(col,1.0);\n    }\n    //else fragColor = vec4(0.0);\n\n    \n}",
      "name": "Image",
      "description": "",
      "type": "image"
    }
  ]
}