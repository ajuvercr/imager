{
  "ver": "0.1",
  "info": {
    "id": "wlf3WX",
    "date": "1557839007",
    "viewed": 2552,
    "name": "Head",
    "username": "tdhooper",
    "description": "Just the head from my [url=https://www.shadertoy.com/view/wtf3RM]4k[/url] and [url=https://twitter.com/tdhooper/status/1120006429191045121]animated gif[/url], including the ears this time.\n\nClick for a close up view.",
    "likes": 84,
    "published": 3,
    "flags": 0,
    "tags": [
      "head",
      "human",
      "anatomy"
    ],
    "hasliked": 0,
    "usePreview": 0
  },
  "renderpass": [
    {
      "inputs": [],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "/*\n\nHead\n----\n\nThis was painstakingly hand modeled by 'tracing' a polygonal model\nexported from Daz 3D.\n\nThe initial approach is to smooth blend small ellipses with a large\nblend radius, a technique I took from Ink Drawing by lnae\n(https://www.shadertoy.com/view/MltcDB)\n\nThe brow and jawline are formed by blending planes and spheres.\nThe nose is, of course, a few capsules.\nThe ears are various extruded and warped 2D layers, they were by\nfar the hardest part.\n\nI encourage you to comment parts out and see how it all adds up.\n\nUses a few primitives and tools from HG_SDF and IQ.\n\nApologies for the boring shading, you can see some more interesting\napplications in the GIF and 4K that this was created for:\n\n* Fractal Polycephaly https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/giphy.gif\n* ᴇ s ᴄ ʜ ᴇ ʀ ᴡ ᴀ ᴠ ᴇ https://www.shadertoy.com/view/wtf3RM\n\n\nLicense: Creative Commons Attribution-NonCommercial\nhttps://creativecommons.org/licenses/by-nc/4.0/\n\n*/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nbool isEye = false;\n\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    p.y -= .11;\n\n    vec3 pa = p;\n    vec3 ps = p;\n    ps.x = sqrt(ps.x * ps.x + .0005);\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = ps;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = ps;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n    \n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // jaw\n\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = ps + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    //return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n\tisEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}\n\nfloat sstep(float t) {\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\n}\n\nfloat map(vec3 p) {\n    \n    float scale = 1.;\n    float s = .2;\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\n    float rx = sin(iTime * .33) * .2;\n\n    if (iMouse.z > 0.) {\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;\n    \trx = (.5 - iMouse.y / iResolution.y) * PI / 2.;\n        scale = 2.;\n    }\n    \n    pR(p.yz, rx);\n    pR(p.xz, ry);\n    \n    p /= scale;\n   \treturn mHead(p) * scale;\n}\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0005,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,3.2);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n    vec3 col = vec3(.1);\n\n    for (int i = 0; i < 150; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        dist = map(rayPosition);\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 5.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        vec3 albedo = isEye ? vec3(2) : vec3(1);\n        vec3 n = calcNormal(rayPosition);\n        vec3 lp = vec3(-.5,.5,.5);\n        float l = max(dot(lp, n), 0.);\n        vec3 ld = normalize(lp - rayPosition);\n        l += .02;\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\n        col = albedo * l;\n        col = pow(col, vec3(1./2.2));\n    }\n\n    fragColor = vec4(col,1);\n}\n",
      "name": "Image",
      "description": "",
      "type": "image"
    }
  ]
}