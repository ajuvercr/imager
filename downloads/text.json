{
  "ver": "0.1",
  "info": {
    "id": "cld3D4",
    "date": "1682448654",
    "viewed": 1,
    "name": "Fork text perfo no textureGrad",
    "username": "silvius",
    "description": "WIP\n\nbitmap ascii to display performance uniforms in the frame",
    "likes": 0,
    "published": 3,
    "flags": 0,
    "tags": [
      "text",
      "bitmap"
    ],
    "hasliked": 0,
    "usePreview": 0
  },
  "renderpass": [
    {
      "inputs": [
        {
          "id": 49,
          "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
          "ctype": "texture",
          "channel": 0,
          "sampler": {
            "filter": "mipmap",
            "wrap": "clamp",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "//INCOMPLETE merger of my \"ascii text wrapper\" (includes someone elses ascii text renderer)\n//and \"texture morph\" from https://www.shadertoy.com/view/ltcXzs\n\n//splits functions into a container that displays some overlay text\n//and a content function that has the rest of the shader.\n\n//2 elements work, but are too seperate, shouls use more of the same subroutines.\n//goal is simply to have sdf font replace ascii text here.\n\n\n// --- access to the image of ascii code c\nvec4 char(vec2 p, int C) {\n  vec4 tex = texture(iChannel0,p/16.+fract(vec2(C,15-C/16)/16.));\n  \n  //if(isInside2(p)==0.)return vec4(0);return vec4(0,0,0,1e5);\n  if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n  //terrible branching framing\n  return tex;\n  \n  //return textureLod( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n  //                   log2(length(fwidth(p/16.*iResolution.xy))) );\n    // return textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                   \n    // possible variants: (but better separated in an upper function) \n    //     - inout pos and include pos.x -= .5 + linefeed mechanism\n    //     - flag for bold and italic \n}\n//xy has [0.0] on the top left, coplying with reading direction.\n//vec4 chargrid(vec2 p,int c,vec2 xy){\n//}\n\nvec4 charmorph(in vec2 U){\n float t=3.*iTime;\n vec4 O=char(U,int(t));     // try .xxxx for mask, .wwww for distance field.\n vec4 O2=char(U,int(++t));\n O=mix(O,O2,fract(t));             // linear morphing \n //O = sqrt(mix(O*O,O2*O2,fract(t)));  // quadratic morphing\n O =  smoothstep(.5,.49,O.wwww)\n *O.yzww;                        // comment for B&W\n    //O+=.5;O*=O*O;O-=.5;//cubic contrast;\n    return O;\n}\n\n//isInside returns distance to a square \n//with center offset by offsetXY=.5;\n//and with HalfSizeXY=.5;\nfloat isInside(vec2 p, vec2 c){\n p.x*=2.;c.x*=2.;//scaling\n float offsetXY=.0;\n vec2 d=abs(p-offsetXY-c)-.5;\n return-max(d.x,d.y);}\n//offsetXY and HalfSizeXY could easily be the same input parameter.\n//scaling for IsInside() may be fster if it takes a mat2 as input.\n\n\n\nvoid mainImage2(out vec4 O,vec2 p){\n p/=iResolution.y;\n\n  O=charmorph(p);//morphing char.\n    \n  // \"Morphing\" text\n\n  float Lines=10.;\n  \n  p *= 8.;//make smaller\n  p.x -=9.;\n  O += char(p,64+13   ).x;p.x-=.5;\n  O += char(p,64+15+32).x;p.x-=.5;\n  O += char(p,64+18+32).x;p.x-=.5;\n  O += char(p,64+16+32).x;p.x-=.5;\n  O += char(p,64+ 8+32).x;p.x-=.5;\n  O += char(p,64+ 9+32).x;p.x-=.5;\n  O += char(p,64+14+32).x;p.x-=.5;\n  O += char(p,64+ 7+32).x;p.x-=.5;\n    \n    /*\n\t//vec2 p =i.xy/iResolution.xy;\n    //p.y*=iResolution.y/iResolution.x;\n    p*=4.;\n\tO = vec4(p,0.5+0.5*sin(iTime),1.0);\n    vec2 m=iMouse.xy/iResolution.xy;\n    m.y*=iResolution.y/iResolution.x;\n    m*=4.;\n    //if(length(p.xy-m.xy)<.5){\n\n    float delta=0.0;//this shows that its a gradient.\n    if (isInside(p,m)>delta)O*=.25;//inside is darker\n    //else r*=2.;//is outside, make brighter \n    //}\n*/\n}\n\n///--end of mainimage2 content, start of its mainimage() container:\n///--end of mainimage2 content, start of its mainimage() container:\n\n\n//the line that contains \"greaterThanEqual\" nicely shows integer 2d clipping\n#define DOWN_SCALE 1.//poor scaling\n#define MAX_INT_DIGITS 4\n#define CHAR_SIZE vec2(8,12)\n#define CHAR_SPACING vec2(8,12)\n#define STRWIDTH(c)(c*CHAR_SPACING.x)\n#define STRHEIGHT(c)(c*CHAR_SPACING.y)\nint TEXT_MODE=0;//0=normal 1=inverted 2=underlined\n/* glyph bitmap codec: it uses 4x24 bits of a vec4() of type float, set in hexadecimal.\n--------\n-XXX----\nXX-XX--- -> 0x0070D8\nXX-XX---\n-XXX----\nXXXXX-X- -> 0xD870FA\nXX-XXXX-\nXX--XX--\nXX-XXX-- -> 0xDECCDC\n-XXX-XX-\n--------\n-------- -> 0x760000\n\"-\" -> 0 , \"X\"-> 1\nsplit to 4 8x3 (24 bit) chunks, 3 lines per chunk, for each component of the vec4.\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\nAutomatically generated from the 8x12 font sheet here:\nhttp://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\n//no ASCII table, because i cant make a binary tree,gl_es lacks bitwise operators\n//i really think this is were i split with GL_ES, poor bitwise support.\n//being able to ASCII and string is kind of a deal breaker!\n#define hex0 0x000000\n#define hexC 0xCCCCCC\n#define cc87 0x0078CC \n#define he78 0x780000\n#define he30 0x303030\nvec4 _spc=vec4(hex0,hex0,hex0,hex0);// space\nvec4 _exc=vec4(0x003078,0x787830,0x300030,0x300000);// !\nvec4 _quo=vec4(0x006666,0x662400,hex0,hex0);// \"\nvec4 _hsh=vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 _dol=vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 _pct=vec4(hex0,0xC4CC18,0x3060CC,0x8C0000);// %\nvec4 _amp=vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);// &\nvec4 _apo=vec4(0x003030,0x306000,hex0,hex0);\nvec4 _lbr=vec4(0x000C18,0x306060,0x603018,0x0C0000);// [\nvec4 _rbr=vec4(0x006030,0x180C0C,0x0C1830,0x600000);// ]\nvec4 _ast=vec4(hex0,0x663CFF,0x3C6600,hex0);// *\nvec4 _crs=vec4(hex0,0x18187E,0x181800,hex0);\nvec4 _com=vec4(hex0,hex0,0x000038,0x386000);// ,\nvec4 _dsh=vec4(hex0,0x0000FE,hex0,hex0);// /\nvec4 _per=vec4(hex0,hex0,0x000038,0x380000);// %\nvec4 _lsl=vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 _0=vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);vec4 _1=vec4(0x001030,0xF03030,he30,0xFC0000);vec4 _2=vec4(cc87,0xCC0C18,0x3060CC,0xFC0000);vec4 _3=vec4(cc87,0x0C0C38,0x0C0CCC,he78);vec4 _4=vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);vec4 _5=vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,he78);vec4 _6=vec4(0x003860,0xC0C0F8,hexC,he78);\nvec4 _7=vec4(0x00FEC6,0xC6060C,0x183030,0x300000);vec4 _8=vec4(cc87,0xCCEC78,0xDCCCCC,he78);vec4 _9=vec4(cc87,0xCCCC7C,0x181830,0x700000);\nvec4 _col=vec4(hex0,0x383800,0x003838,hex0);\nvec4 _scl=vec4(hex0,0x383800,0x003838,0x183000);\nvec4 _les=vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 _equ=vec4(hex0,0x007E00,0x7E0000,hex0);\nvec4 _grt=vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 _que=vec4(cc87,0x0C1830,0x300030,0x300000);\nvec4 _ats=vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 _A=vec4(0x003078,hexC,0xFCCCCC,0xCC0000);vec4 _B=vec4(0x00FC66,0x66667C,0x666666,0xFC0000);vec4 _C=vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);vec4 _D=vec4(0x00F86C,0x666666,0x66666C,0xF80000);vec4 _E=vec4(0x00FE62,0x60647C,0x646062,0xFE0000);vec4 _F=vec4(0x00FE66,0x62647C,0x646060,0xF00000);vec4 _G=vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);vec4 _H=vec4(0x00CCCC,0xCCCCFC,hexC,0xCC0000);vec4 _I=vec4(0x007830,he30,he30,he78);\nvec4 _J=vec4(0x001E0C,0x0C0C0C,hexC,he78);vec4 _K=vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);vec4 _L=vec4(0x00F060,0x606060,0x626666,0xFE0000);vec4 _M=vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);vec4 _N=vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);vec4 _O=vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);vec4 _P=vec4(0x00FC66,0x66667C,0x606060,0xF00000);vec4 _Q=vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);vec4 _R=vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 _S=vec4(cc87,0xCCC070,0x18CCCC,he78);vec4 _T=vec4(0x00FCB4,he30,he30,he78);vec4 _U=vec4(0x00CCCC,hexC,hexC,he78);vec4 _V=vec4(0x00CCCC,hexC,0xCCCC78,0x300000);vec4 _W=vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);vec4 _X=vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);vec4 _Y=vec4(0x00CCCC,0xCCCC78,he30,he78);vec4 _Z=vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);vec4 _lsb=vec4(0x003C30,he30,he30,0x3C0000);vec4 _rsl=vec4(0x000080,0xC06030,0x180C06,0x020000);vec4 _rsb=vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);vec4 _pow=vec4(0x10386C,0xC60000,hex0,hex0);vec4 _usc=vec4(hex0,hex0,hex0,0x00FF00);\nvec4 _a=vec4(hex0,0x00780C,0x7CCCCC,0x760000);vec4 _b=vec4(0x00E060,0x607C66,0x666666,0xDC0000);vec4 _c=vec4(hex0,cc87,0xC0C0CC,he78);vec4 _d=vec4(0x001C0C,0x0C7CCC,hexC,0x760000);vec4 _e=vec4(hex0,cc87,0xFCC0CC,he78);vec4 _f=vec4(0x00386C,0x6060F8,0x606060,0xF00000);vec4 _g=vec4(hex0,0x0076CC,0xCCCC7C,0x0CCC78);vec4 _h=vec4(0x00E060,0x606C76,0x666666,0xE60000);vec4 _i=vec4(0x001818,0x007818,0x181818,0x7E0000);vec4 _j=vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);vec4 _k=vec4(0x00E060,0x60666C,0x786C66,0xE60000);vec4 _l=vec4(0x007818,0x181818,0x181818,0x7E0000);vec4 _m=vec4(hex0,0x00FCD6,0xD6D6D6,0xC60000);vec4 _n=vec4(hex0,0x00F8CC,hexC,0xCC0000);vec4 _o=vec4(hex0,cc87,hexC,he78);vec4 _p=vec4(hex0,0x00DC66,0x666666,0x7C60F0);vec4 _q=vec4(hex0,0x0076CC,hexC,0x7C0C1E);vec4 _r=vec4(hex0,0x00EC6E,0x766060,0xF00000);vec4 _s=vec4(hex0,cc87,0x6018CC,he78);vec4 _t=vec4(0x000020,0x60FC60,0x60606C,0x380000);vec4 _u=vec4(hex0,0x00CCCC,hexC,0x760000);vec4 _v=vec4(hex0,0x00CCCC,0xCCCC78,0x300000);vec4 _w=vec4(hex0,0x00C6C6,0xD6D66C,0x6C0000);vec4 _x=vec4(hex0,0x00C66C,0x38386C,0xC60000);vec4 _y=vec4(hex0,0x006666,0x66663C,0x0C18F0);vec4 _z=vec4(hex0,0x00FC8C,0x1860C4,0xFC0000);\nvec4 _lpa=vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 _bar=vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 _rpa=vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 _tid=vec4(0x0073DA,0xCE0000,hex0,hex0);\nvec4 _lar=vec4(hex0,0x10386C,0xC6C6FE,hex0);\nvec2 print_pos=vec2(0);//cursor position, (0,0)==bottom left.\n//get bit b from given number; Shift right (num / 2^bit), AND the result with 1 (mod(result,2.))\nfloat ebi(float n,float b){b=clamp(b,-1.,24.);return floor(mod(floor(n/pow(2.,floor(b))),2.));}\n//Return pixel at v in the given bit-packed sprite.\nfloat sprite(vec4 j, vec2 s,vec2 v){v=floor(v);\n if(all(greaterThanEqual(v,vec2(0)))&&all(lessThan(v,s))){//Clipping bound\n   float b=(s.x-v.x-1.)+v.y*s.x;//Calculate bit to extract (x+y*width)(flipped on x-axis)\n   return ebi(j.x,b-72.)+ebi(j.y,b-48.)+ebi(j.z,b-24.)+ebi(j.w,b);}return 0.;}\n//Print character and move print_pos forward by 1 character width.\nfloat char(vec4 ch,vec2 uv){//modify uv by any offset.\n      if(TEXT_MODE==1)ch=pow(2.,24.)-1.-ch;//Inverts all bits in the character.\n //else if(TEXT_MODE==2)ch.w=floor(ch.w/256.)*256.+255.;//set bottom 8 bits all 1. //i dislike this option\n float r=sprite(ch,CHAR_SIZE,uv-print_pos);print_pos.x+=CHAR_SPACING.x;return r;}\n//Return digit sprite for the given number.\nvec4 get_dig(float x){x=floor(x);\n return x==0.?_0:x==1.?_1:x==2.?_2:x==3.?_3:x==4.?_4:x==5.?_5:x==6.?_6:x==7.?_7:x==8.?_8:x==9.?_9:vec4(0.);}\n//Print number, starting at pos.\n#define d10 float d=mod(n/pow(10.,float(i)),10.);\nfloat print_number(float n,vec2 v){float r=0.;for(int i=3;i>-2;i--){d10 if(i==-1)r+=char(_per,v);//decimal point\n  if(abs(n)>pow(10.,float(i))||i==0)r+=char(get_dig(d),v);}return r;}\nfloat intP(float n,int z,vec2 v){float r=0.;for(int i=MAX_INT_DIGITS;i>=0;i--){d10\n if(abs(n)>pow(10.,float(i))||z>i||i==0)r+=char(get_dig(d),v);}return r;}\n//int getDigCD(float d){return int(1./pow(10.,d));}//return number of decimal digits\n#define _ ,uv)+char( \n#define tmi TEXT_MODE=1;r+=char(\n#define tmn TEXT_MODE=0;r+=char(\n float textfps(vec2 uv){print_pos=vec2(2,2.+STRHEIGHT(1.));\n float r=intP(1./iTimeDelta,0 _ _amp _ _spc,uv)//fps\n     +intP(float(iFrame)/iTime,0 _ _f _ _p _ _s _ _equ,uv)//total average fps\n     +intP(float(iFrame),0 _ _f _ _r _ _a _ _m _ _e _ _lsl,uv)+intP(iTime*1000.,0 _ _m _ _s,uv)\n     ;\n print_pos=vec2(2,2.+STRHEIGHT(0.));tmi _D _ _a _ _t _ _e,uv);tmn _col,uv);\n r+=intP(iDate.x,4 _ _dsh,uv)+intP(iDate.y+1.,2 _ _dsh,uv)+intP(iDate.z,2 _ _lsl,uv);//date\n r+=intP(floor(iDate.w/3600.),2 _ _col,uv)+intP(floor(mod(iDate.w/60.,60.)),2 _ _col,uv)//hour+min\n +intP(floor(mod(iDate.w,60.)),2,uv);tmn _spc,uv);//sec\n tmi _R _ _e _ _s,uv); tmn _col,uv);return r+intP(iResolution.x,0 _ _x,uv)+intP(iResolution.y,0,uv);}//res\n\n\n\n\nvoid mainImage(out vec4 c,vec2 i){\n c=vec4(0);c.w=1.;                  //initial tinting for compatibility.\n float t=textfps(i);  //overlay test\n if(t==1.)c=vec4(1.0);              //if (fragment is 100%text) skip rendering of content\n else mainImage2(c,i);//render content\n}\n",
      "name": "Image",
      "description": "",
      "type": "image"
    }
  ]
}