{
  "ver": "0.1",
  "info": {
    "id": "4tlBWH",
    "date": "1511785518",
    "viewed": 8617,
    "name": "Morning city & aurora & bloom",
    "username": "uqone",
    "description": "Just Devin's amazing \"Morning City\" (https://www.shadertoy.com/view/XsBSRG) with aurora stolen from Nimitz's awesome \"Auroras\" (https://www.shadertoy.com/view/XtGGRt), and simple crappy bloom post processing by me.\n\nAll credits to Devin, and nimitz.\n",
    "likes": 41,
    "published": 3,
    "flags": 32,
    "tags": [
      "procedural",
      "3d",
      "city"
    ],
    "hasliked": 0,
    "usePreview": 1
  },
  "renderpass": [
    {
      "inputs": [
        {
          "id": 257,
          "src": "/media/previz/buffer00.png",
          "ctype": "buffer",
          "channel": 0,
          "sampler": {
            "filter": "linear",
            "wrap": "clamp",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "//#define SHOW_DEPTHMAP\n//#define USE_ANAGLYPH_3D\n#define AnaglyphParallax 5.0\n\n\n#define px (vec2(1.0) / iResolution.xy)\n\nvec4 GetBloom ( in vec2 uv, in vec4 inColor )\n{\n\tfloat numSamples = 1.0;\n    vec4 color = inColor;\n\n\tfor (float x = -8.0; x <= 8.0; x += 1.0)\n\t{\n\t\tfor (float y = -8.0; y <= 8.0; y += 1.0)\n\t\t{\n\t\t\tvec4 addColor = texture(iChannel0, vec2(1.0) - uv + (vec2(x, y) * px));\n\t\t\tif (max(addColor.r, max(addColor.g, addColor.b)) > 0.3)\n\t\t\t{\n\t\t\t\tfloat dist = length(vec2(x,y))+1.0;\n#ifdef USE_ANAGLYPH_3D\n                vec4 glowColor = max((addColor * 156.0) / pow(dist, 2.0), vec4(0.0));\n#else\n\t\t\t\tvec4 glowColor = max((addColor * 128.0) / pow(dist, 2.0), vec4(0.0));\n#endif\n\t\t\t\tif (max(glowColor.r, max(glowColor.g, glowColor.b)) > 0.0)\n\t\t\t\t{\n\t\t\t\t\tcolor += glowColor;\n\t\t\t\t\tnumSamples += 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \n\treturn color / numSamples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n#ifdef SHOW_DEPTHMAP\n    vec2 uv1 = fragCoord.xy / iResolution.xy;\n    float a = clamp(texture(iChannel0, vec2(1.0) - uv1).a / 6.0, 0.0, 1.0);\n    fragColor =  vec4(a, a, a, 1.0);\n    return;\n#endif\n    \n#ifndef USE_ANAGLYPH_3D\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color =  texture(iChannel0, vec2(1.0) - uv);\n    fragColor = mix(color, GetBloom(uv, color), 0.05);\n#else\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 Anaglyph = texture(iChannel0, vec2(1.0) - uv, 0.0);\n    float depth = clamp(Anaglyph.a / 3.0, 0.0, 1.0);\n    \n    // Left Eye (Red)\n    vec2 uv_l = vec2(uv + (vec2(-AnaglyphParallax*depth,0)*px));\n    vec4 color_l = texture(iChannel0, vec2(1.0) - uv_l);\n    color_l = mix(color_l, GetBloom(uv_l, color_l), 0.05);\n\n\t// Right Eye (Cyan)\n    vec2 uv_r = vec2(uv + (vec2(AnaglyphParallax*depth,0)*px));\n\tvec4 color_r = texture(iChannel0, vec2(1.0) - uv_r);\n    color_r = mix(color_r, GetBloom(uv_r, color_r), 0.05);\n    \n    mat3x3 m0 = mat3x3(\n                0.4155, -0.0458, -0.0545,\n                0.4710, -0.0484, -0.0614,\n                0.1670, -0.0258,  0.0128);\n \n\tmat3x3 m1 = mat3x3(\n                -0.0109, 0.3756, -0.0651,\n                -0.0365, 0.7333, -0.1286,\n                -0.0060, 0.0111,  1.2968);\n    \n    // calculate resulting pixel\n\tfragColor.rgb = (m0 * color_r.rgb) + (m1 * color_l.rgb);\n#endif\n    \n    fragColor.a = 1.0;\n}\n",
      "name": "Image",
      "description": "",
      "type": "image"
    },
    {
      "inputs": [
        {
          "id": 35,
          "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3",
          "ctype": "music",
          "channel": 1,
          "sampler": {
            "filter": "linear",
            "wrap": "clamp",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 257,
          "channel": 0
        }
      ],
      "code": "//#define WINDOW_MUSIC_BLINK // Disabled by default - Blinks can be bad for some people.\n#define CARS\n#define I_MAX 70\n\nfloat rand(vec2 n) {\n  return fract(sin((n.x*1e2+n.y*1e4+1475.4526)*1e-4)*1e6);\n}\n\nfloat noise(vec2 p)\n{\n    p = floor(p*200.0);\n\treturn rand(p);\n}\n\n#define time (iTime+1024.0)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = triNoise2d(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n\nvec3 polygonXY(float z,vec2 vert1, vec2 vert2, vec3 camPos,vec3 rayDir){\n    float t = -(camPos.z-z)/rayDir.z;\n    vec2 cross = camPos.xy + rayDir.xy*t;\n    if (cross.x>min(vert1.x,vert2.x) && \n        cross.x<max(vert1.x,vert2.x) &&\n       \tcross.y>min(vert1.y,vert2.y) &&\n       \tcross.y<max(vert1.y,vert2.y) &&\n       dot(rayDir,vec3(cross,z)-camPos)>0.0){\n        \tfloat dist = length(camPos-vec3(cross,z));\n            return vec3(dist, cross.x-min(vert1.x,vert2.x),cross.y-min(vert1.y,vert2.y));\n        }\n    \n    return vec3(101.0,0.0,0.0);\n}\nvec3 polygonYZ(float x,vec2 vert1, vec2 vert2, vec3 camPos,vec3 rayDir){\n    float t = -(camPos.x-x)/rayDir.x;\n    vec2 cross1 = camPos.yz + rayDir.yz*t;\n    if (cross1.x>min(vert1.x,vert2.x) && \n        cross1.x<max(vert1.x,vert2.x) &&\n       \tcross1.y>min(vert1.y,vert2.y) &&\n       \tcross1.y<max(vert1.y,vert2.y)&&\n       dot(rayDir,vec3(x,cross1)-camPos)>0.0){\n        \tfloat dist = length(camPos-vec3(x,cross1));\n            return vec3(dist, cross1.x-min(vert1.x,vert2.x),cross1.y-min(vert1.y,vert2.y));\n        }\n    \n    return vec3(101.0,0.0,0.0);\n}\nvec3 polygonXZ(float y,vec2 vert1, vec2 vert2, vec3 camPos,vec3 rayDir){\n    float t = -(camPos.y-y)/rayDir.y;\n    vec2 cross1 = camPos.xz + rayDir.xz*t;\n    if (cross1.x>min(vert1.x,vert2.x) && \n        cross1.x<max(vert1.x,vert2.x) &&\n       \tcross1.y>min(vert1.y,vert2.y) &&\n       \tcross1.y<max(vert1.y,vert2.y)&&\n       dot(rayDir,vec3(cross1.x,y,cross1.y)-camPos)>0.0){\n        \tfloat dist = length(camPos-vec3(cross1.x,y,cross1.y));\n            return vec3(dist, cross1.x-min(vert1.x,vert2.x),cross1.y-min(vert1.y,vert2.y));\n        }\n    \n    return vec3(101.0,0.0,0.0);\n}\n\nvec3 textureWall(vec2 pos, vec2 maxPos, vec2 squarer,float s,float height,float dist,vec3 rayDir,vec3 norm, out vec3 windowColor, float winBlink){\n    float randB = rand(squarer*2.0);\n    windowColor =(-0.4+randB*0.8)*vec3(0.3,0.3,0.0)+(-0.4+fract(randB*10.0)*0.8)*vec3(0.0,0.0,0.3)+(-0.4+fract(randB*10000.0)*0.8)*vec3(0.3,0.0,0.0);\n    float floorFactor = 1.0;\n    vec2 windowSize = vec2(0.65,0.35);\n    vec3 wallColor = s*(0.3+1.4*fract(randB*100.0))*vec3(0.1,0.1,0.1)+(-0.7+1.4*fract(randB*1000.0))*vec3(0.02,0.,0.);\n\twallColor*=1.3;\n    \n    vec3 color = vec3(0.0);\n    vec3 conturColor = wallColor/1.5;\n    if (height<0.51){\n    \twindowColor += vec3(0.3,0.3,0.0);\n        windowSize = vec2(0.4,0.4);\n        floorFactor = 0.0;\n\n    }\n    if (height<0.6){floorFactor = 0.0;}\n    if (height>0.75){\n    \twindowColor += vec3(0.0,0.0,0.3);\n    }\n    windowColor*=1.5;\n    float wsize = 0.02;\n    wsize+=-0.007+0.014*fract(randB*75389.9365);\n    windowSize+= vec2(0.34*fract(randB*45696.9365),0.50*fract(randB*853993.5783));\n    \n    vec2 contur=vec2(0.0)+(fract(maxPos/2.0/wsize))*wsize;\n    if (contur.x<wsize){contur.x+=wsize;}\n    if (contur.y<wsize){contur.y+=wsize;}\n    \n\tvec2 winPos = (pos-contur)/wsize/2.0-floor((pos-contur)/wsize/2.0);\n    \n    float numWin = floor((maxPos-contur)/wsize/2.0).x;\n    \n    if ( (maxPos.x>0.5&&maxPos.x<0.6) && ( ((pos-contur).x>wsize*2.0*floor(numWin/2.0)) && ((pos-contur).x<wsize*2.0+wsize*2.0*floor(numWin/2.0)) )){\n     \t   return (0.9+0.2*noise(pos))*conturColor;\n    }\n    \n    if ( (maxPos.x>0.6&&maxPos.x<0.7) &&( ( ((pos-contur).x>wsize*2.0*floor(numWin/3.0)) && ((pos-contur).x<wsize*2.0+wsize*2.0*floor(numWin/3.0)) )||\n                                          ( ((pos-contur).x>wsize*2.0*floor(numWin*2.0/3.0)) && ((pos-contur).x<wsize*2.0+wsize*2.0*floor(numWin*2.0/3.0)) )) ){\n     \t   return (0.9+0.2*noise(pos))*conturColor;\n    }\n    \n    if ( (maxPos.x>0.7) &&( ( ((pos-contur).x>wsize*2.0*floor(numWin/4.0)) && ((pos-contur).x<wsize*2.0+wsize*2.0*floor(numWin/4.0)) )||\n                                          ( ((pos-contur).x>wsize*2.0*floor(numWin*2.0/4.0)) && ((pos-contur).x<wsize*2.0+wsize*2.0*floor(numWin*2.0/4.0)) )||\n                                          ( ((pos-contur).x>wsize*2.0*floor(numWin*3.0/4.0)) && ((pos-contur).x<wsize*2.0+wsize*2.0*floor(numWin*3.0/4.0)) )) ){\n     \t   return (0.9+0.2*noise(pos))*conturColor;\n    }\n    if ((maxPos.x-pos.x<contur.x)||(maxPos.y-pos.y<contur.y+2.0*wsize)||(pos.x<contur.x)||(pos.y<contur.y)){\n            return (0.9+0.2*noise(pos))*conturColor;\n        \n    }\n    if (maxPos.x<0.14) {\n     \t   return (0.9+0.2*noise(pos))*wallColor;\n    }\n    vec2 window = floor((pos-contur)/wsize/2.0);\n    float random = rand(squarer*s*maxPos.y+window);\n    float randomZ = rand(squarer*s*maxPos.y+floor(vec2((pos-contur).y,(pos-contur).y)/wsize/2.0));\n    float windows = floorFactor*sin(randomZ*5342.475379+(fract(975.568*randomZ)*0.15+0.05)*window.x);\n    \n\tfloat blH = 0.06*dist*600.0/iResolution.x/abs(dot(normalize(rayDir.xy),normalize(norm.xy)));\n    float blV = 0.06*dist*600.0/iResolution.x/sqrt(abs(1.0-pow(abs(rayDir.z),2.0)));\n    \n\twindowColor +=vec3(1.0,1.0,1.0);\n    windowColor *= smoothstep(0.5-windowSize.x/2.0-blH,0.5-windowSize.x/2.0+blH,winPos.x);\n   \twindowColor *= smoothstep(0.5+windowSize.x/2.0+blH,0.5+windowSize.x/2.0-blH,winPos.x);\n   \twindowColor *= smoothstep(0.5-windowSize.y/2.0-blV,0.5-windowSize.y/2.0+blV,winPos.y);\n   \twindowColor *= smoothstep(0.5+windowSize.y/2.0+blV,0.5+windowSize.y/2.0-blV,winPos.y);\n    \n#ifdef WINDOW_MUSIC_BLINK\n    windowColor *= (1.5 + (pow(clamp(winBlink*4.0, 0.0, 1.5), 4.0))) / 2.0;\n#else\n    windowColor *= 1.5;\n#endif\n    \n    if ((random <0.05*(3.5-2.5*floorFactor))||(windows>0.65)){\n        \tif (winPos.y<0.5) {windowColor*=(1.0-0.4*fract(random*100.0));}\n        \tif ((winPos.y>0.5)&&(winPos.x<0.5)) {windowColor*=(1.0-0.4*fract(random*10.0));}\n            return (0.9+0.2*noise(pos))*wallColor+(0.9+0.2*noise(pos))*windowColor;\n\n\n    } \n    else{\n        windowColor*=0.08*fract(10.0*random);\n    }\n    \n    return (0.9+0.2*noise(pos))*wallColor+windowColor;\n\n}\n\nvec3 textureRoof(vec2 pos, vec2 maxPos,vec2 squarer){\n    float wsize = 0.025;\n    float randB = rand(squarer*2.0);\n    vec3 wallColor = (0.3+1.4*fract(randB*100.0))*vec3(0.1,0.1,0.1)+(-0.7+1.4*fract(randB*1000.0))*vec3(0.02,0.,0.);\n\tvec3 conturColor = wallColor*1.5/2.5;\n    vec2 contur = vec2(0.02);\n    if ((maxPos.x-pos.x<contur.x)||(maxPos.y-pos.y<contur.y)||(pos.x<contur.x)||(pos.y<contur.y)){\n            return (0.9+0.2*noise(pos))*conturColor;\n        \n    }\n    float step1 = 0.06+0.12*fract(randB*562526.2865);\n    pos -=step1;\n    maxPos -=step1*2.0;\n    if ((pos.x>0.0&&pos.y>0.0&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y))){\n            return (0.9+0.2*noise(pos))*conturColor;\n        \n    }\n    pos -=step1;\n    maxPos -=step1*2.0;\n    if ((pos.x>0.0&&pos.y>0.0&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y))){\n            return (0.9+0.2*noise(pos))*conturColor;\n        \n    }\n    pos -=step1;\n    maxPos -=step1*2.0;\n    if ((pos.x>0.0&&pos.y>0.0&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y))){\n            return (0.9+0.2*noise(pos))*conturColor;\n        \n    }\n    \n    return (0.9+0.2*noise(pos))*wallColor;\n    \n}\nvec3 cars(vec2 squarer, vec2 pos, float dist,float level){\n    vec3 color = vec3(0.0);\n    float carInten = 3.5/sqrt(dist);\n    float carRadis = 0.01; \n    if (dist>2.0) {carRadis *= sqrt(dist/2.0);}\n    vec3 car1 = vec3(0.5,0.5,1.0);\n    vec3 car2 = vec3(1.0,0.1,0.1);\n    float carNumber = 0.5;\n    \n    float random = noise((level+1.0)*squarer*1.24435824);\n    for (int j=0;j<10; j++){\n        float i = 0.03+float(j)*0.094;\n        if(fract(random*5.0/i)>carNumber){color += car1*carInten*smoothstep(carRadis,0.0,length(pos - vec2(fract(i+iTime/4.0),0.025)));}\n        \n        if(fract(random*10.0/i)>carNumber){color += car2*carInten*smoothstep(carRadis,0.0,length(pos - vec2(fract(i-iTime/4.0),0.975)));}\n    \tif(color.x>0.0) break;\n    }\n    for (int j=0;j<10; j++){\n        float i= 0.03+float(j)*0.094;\n        if(fract(random*5.0/i)>carNumber){color += car2*carInten*smoothstep(carRadis,0.0,length(pos - vec2(0.025,fract(i+iTime/4.0))));}\n        if(fract(random*10.0/i)>carNumber){color += car1*carInten*smoothstep(carRadis,0.0,length(pos - vec2(0.975,fract(i-iTime/4.0))));}\n        \tif(color.x>0.0) break;\n\n    }\n    for (int j=0;j<10; j++){\n        float i = 0.03+0.047+float(j)*0.094;\n        if(fract(random*100.0/i)>carNumber){color += car1*carInten*smoothstep(carRadis,0.0,length(pos - vec2(fract(i+iTime/4.0),0.045)));}\n        if(fract(random*1000.0/i)>carNumber){color += car2*carInten*smoothstep(carRadis,0.0,length(pos - vec2(fract(i-iTime/4.0),0.955)));}\n        \tif(color.x>0.0) break;\n\n    }\n    for (int j=0;j<10; j++){\n        float i = 0.03+0.047+float(j)*0.094;\n        if(fract(random*100.0/i)>carNumber){color += car2*carInten*smoothstep(carRadis,0.0,length(pos - vec2(0.045,fract(i+iTime/4.0))));}\n        if(fract(random*1000.0/i)>carNumber){color += car1*carInten*smoothstep(carRadis,0.0,length(pos - vec2(0.955,fract(i-iTime/4.0))));}\n        \tif(color.x>0.0) break;\n\n    }\n    return color;\n}\nvec3 textureGround(vec2 squarer, vec2 pos,vec2 vert1,vec2 vert2,float dist){\n    vec3 color = (0.9+0.2*noise(pos))*vec3(0.1,0.15,0.1);\n    float randB = rand(squarer*2.0);\n\n    vec3 wallColor = (0.3+1.4*fract(randB*100.0))*vec3(0.1,0.1,0.1)+(-0.7+1.4*fract(randB*1000.0))*vec3(0.02,0.,0.);\n\tfloat fund = 0.03;\n    float bl = 0.01;\n    float f = smoothstep(vert1.x-fund-bl,vert1.x-fund,pos.x);\n    f *= smoothstep(vert1.y-fund-bl,vert1.y-fund,pos.y);\n    f *= smoothstep(vert2.y+fund+bl,vert2.y+fund,pos.y);\n    f *= smoothstep(vert2.x+fund+bl,vert2.x+fund,pos.x);\n\n    pos -= 0.0;\n    vec2 maxPos = vec2(1.,1.);\n    vec2 contur = vec2(0.06,0.06);\n    if ((pos.x>0.0&&pos.y>0.0&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y))){\n            color =  vec3(0.1,0.1,0.1)*(0.9+0.2*noise(pos));\n        \n    }\n    pos -= 0.06;\n    maxPos = vec2(.88,0.88);\n    contur = vec2(0.01,0.01);\n    if ((pos.x>0.0&&pos.y>0.0&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y))){\n            color =  vec3(0.,0.,0.);\n        \n    }\n    color = mix(color,(0.9+0.2*noise(pos))*wallColor*1.5/2.5,f);\n\n    pos+=0.06;\n    \n#ifdef CARS\n    if (pos.x<0.07||pos.x>0.93||pos.y<0.07||pos.y>0.93){\n        color+=cars(squarer,pos,dist,0.0);\n    }\n#endif\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n    float t = -iTime;\n    float tt = -iTime-0.5;\n    \n    \n    vec3 camPos = vec3(5.0+12.0*sin(t*0.05),5.0+ 7.0*cos(t*0.05), 1.9);\n    \n    vec3 camTarget = vec3(5.0+0.0,5.0+7.0*sin(t*0.05), 0.0);\n    if (fract(t/12.0)<0.25){\n    \tcamPos = vec3(5.*t,3.1*t,2.1);\n\t\tcamTarget = vec3(5.*tt,3.1*tt,1.7);\n    }\n    if (fract(t/12.0)>0.75){\n    \tcamPos = vec3(35.,3.1,1.);\n\t\tcamTarget = vec3(35.+sin(t/10.0),3.1+cos(t/10.0),0.7);\n    }\n    vec3 camDir = normalize(camTarget-camPos);\n    vec3 camUp  = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 camSide = cross(camDir, camUp);\n    camUp  = cross(camDir, camSide);\n    vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*1.6);\n    float angle = 0.03*pow(abs(acos(rayDir.x)),4.0);\n    //angle = min(0.0,angle);\n    vec3 color = vec3(0.0);\n    vec2 square = floor(camPos.xy);\n    square.x += 0.5-0.5*sign(rayDir.x);\n    square.y += 0.5-0.5*sign(rayDir.y);\n    float mind = 100.0;\n    int k = 0;\n    vec3 pol;\n    vec2 maxPos;\n    vec2 crossG;\n    float tSky = -(camPos.z-3.9)/rayDir.z;\n    vec2 crossSky = floor(camPos.xy + rayDir.xy*tSky);\n    bool isGlow = false;\n    \n   //vec3 rd = rayDir;\n   // vec3 ro = camTarget;//vec3(0.0);//camDir*16.0;\n     vec3 ro = camPos/256.0;//vec3(0,0,-6.7);\n    vec3 rd = rayDir * 0.5 + 0.5;//normalize(vec3(pos,1.3));\n    vec3 aurColor = vec3(0.0);\n    float fade = smoothstep(0.0,0.01,abs(rd.y))*0.1+0.9;\n    \n    aurColor = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        aurColor += stars(rd);\n        aurColor = aurColor*(1.-aur.a) + aur.rgb;\n    }\n    \n    float winBlink = 0.0;\n    \n#ifdef WINDOW_MUSIC_BLINK\n    winBlink = 1.0 - texture( iChannel1,square/512.0 ).x;\n#endif\n    \n    for (int i=1; i<I_MAX; i++){\n                \n        vec2 squarer = square-vec2(0.5,0.5)+0.5*sign(rayDir.xy);\n        if (crossSky == squarer&&crossSky!=floor(camPos.xy))\n        {\n        \tcolor += vec3(vec2(0.5,0.15)*abs(angle)*exp(-rayDir.z*rayDir.z*30.0),0.2);\n            color += aurColor;\n            break;\n\n        }\n        float t;\n        float random = rand(squarer);\n        float height = 0.0;\n        float quartalR = rand(floor(squarer/10.0));\n        if (floor(squarer/10.0) == vec2(0.0,0.0)) quartalR = 0.399;\n        if (quartalR<0.4) {\n            height = -0.15+0.4*random+smoothstep(12.0,7.0,length(fract(squarer/10.0)*10.0-vec2(5.0,5.0)))*0.8*random+0.9*smoothstep(10.0,0.0,length(fract(squarer/10.0)*10.0-vec2(5.0,5.0)));\n        \theight*=quartalR/0.4;\n        }\n        float maxJ=2.0;\n        float roof = 1.0;\n        if (height<0.3){\n            height = 0.3*(0.7+1.8*fract(random*100.543264));maxJ = 2.0;\n            if (fract(height*1000.0)<0.04) height*=1.3;\n        }\n        if (height>0.5) {maxJ=3.0;}\n        if (height>0.85){maxJ = 4.0;}\n        if (fract(height*100.0)<0.15){height = pow(maxJ-1.0,0.3)*height; maxJ = 2.0; roof = 0.0;}\n\n        \n        float maxheight = 1.5*pow((maxJ-1.0),0.3)*height+roof*0.07;\n        if (camPos.z+rayDir.z*(length(camPos.xy - square) +0.71 - sign(rayDir.z)*0.71)/length(rayDir.xy)<maxheight){\n\t\t\tvec2 vert1r;\n        \tvec2 vert2r;\n            float zz = 0.0;\n            float prevZZ = 0.0;\n            for(int nf=1;nf<8;nf++){\n                float j = float(nf);\n   \t        \tif(j>maxJ){break;}\n                prevZZ = zz;\n   \t    \t    zz = 1.5*pow(j,0.3)*height;\n                //prevZZ = zz-0.8;\n\n   \t\t     \tfloat dia = 1.0/pow(j,0.3);\n            \tif(j==maxJ){\n                    if (roof == 0.0) {break;}\n      \t\t      \tzz = 1.5*pow((j-1.0),0.3)*height+0.03+0.04*fract(random*1535.347);\n     \t           \tdia = 1.0/pow((j-1.0),0.3)-0.2-0.2*fract(random*10000.0);\n       \t\t    }\n            \n            \tvec2 v1 = vec2(0.0);//vec2(random*10.0,random*1.0);\n            \tvec2 v2 = vec2(0.0);//vec2(random*1000.0,random*100.0);\n                float randomF = fract(random*10.0);\n                if (randomF<0.25){ v1 = vec2(fract(random*1000.0),fract(random*100.0));}\n                if (randomF>0.25&&randomF<0.5){ v1 = vec2(fract(random*100.0),0.0);v2 = vec2(0.0,fract(random*1000.0));}\n                if (randomF>0.5&&randomF<0.75){ v2 = vec2(fract(random*1000.0),fract(random*100.0));}\n                if (randomF>0.75){ v1 = vec2(0.0,fract(random*1000.0)); v2 = vec2(fract(random*100.0),0.0);}\n            \tif (rayDir.y<0.0){\n            \t    float y = v1.y;\n            \t    v1.y = v2.y;\n            \t    v2.y = y;\n            \t}\n            \tif (rayDir.x<0.0){\n            \t    float x = v1.x;\n            \t    v1.x = v2.x;\n            \t    v2.x = x;\n            \t}\n            \n        \t\tvec2 vert1 = square+sign(rayDir.xy)*(0.5-0.37*(dia*1.0-1.0*v1));\n        \t\tvec2 vert2 = square+sign(rayDir.xy)*(0.5+0.37*(dia*1.0-1.0*v2));\n                if (j==1.0){ \n                    vert1r = vec2(min(vert1.x, vert2.x),min(vert1.y,vert2.y));\n                    vert2r = vec2(max(vert1.x, vert2.x),max(vert1.y,vert2.y));\n                }\n            \n        \t\tvec3 pxy = polygonXY(zz,vert1,vert2,camPos,rayDir);\n            \tif (pxy.x<mind){mind = pxy.x; pol = pxy; k=1;maxPos = vec2(abs(vert1.x-vert2.x),abs(vert1.y-vert2.y));}\n            \n        \t\tvec3 pyz = polygonYZ(vert1.x,vec2(vert1.y,prevZZ),vec2(vert2.y,zz),camPos,rayDir);\n            \tif (pyz.x<mind){mind = pyz.x; pol = pyz; k=2;maxPos = vec2(abs(vert1.y-vert2.y),zz-prevZZ);}\n\n        \t\tvec3 pxz = polygonXZ(vert1.y,vec2(vert1.x,prevZZ),vec2(vert2.x,zz),camPos,rayDir);\n            \tif (pxz.x<mind){mind = pxz.x; pol = pxz; k=3;maxPos = vec2(abs(vert1.x-vert2.x),zz-prevZZ);}\n               \t\n\n        \t}\n            \n        \tif ((mind<100.0)&&(k==1)){\n            \tcolor += textureRoof(vec2(pol.y,pol.z),maxPos,squarer);\n                if (mind>3.0){color*=sqrt(3.0/mind);}\n\n            \tbreak;\n        \t} \n        \tif ((mind<100.0)&&(k==2)){\n                vec3 windowColor = vec3(0.0);\n            \tvec3 wallColor = textureWall(vec2(pol.y,pol.z),maxPos,squarer,1.2075624928,height,mind,rayDir,vec3(1.0,0.0,0.0), windowColor, winBlink);\n                color += wallColor;\n            \tif (mind>3.0){color*=sqrt(3.0/mind);}\n                \n                if (length(windowColor.rgb) > 0.7) isGlow = true;\n            \tbreak;\n        \t} \n        \n        \tif ((mind<100.0)&&(k==3)){\n                vec3 windowColor = vec3(0.0);\n            \tvec3 wallColor = textureWall(vec2(pol.y,pol.z),maxPos,squarer,0.8093856205,height,mind,rayDir,vec3(0.0,1.0,0.0), windowColor, winBlink);\n            \tcolor += wallColor;\n                \n               if (length(windowColor.rgb) > 0.7) isGlow = true;\n                if (mind>3.0){color*=sqrt(3.0/mind);}\n\n            \tbreak;\n        \t}\n        \tt = -camPos.z/rayDir.z;\n    \t\tcrossG = camPos.xy + rayDir.xy*t;\n        \tif (floor(crossG) == squarer)\n        \t{\n            \tmind = length(vec3(crossG,0.0)-camPos);\n            \tcolor += textureGround(squarer,fract(crossG),fract(vert1r),fract(vert2r),mind);\n            \tif (mind>3.0){color*=sqrt(3.0/mind);}\n\n            \tbreak;\n        \t}\n        \n        } \n        \n            \n        if ((square.x+sign(rayDir.x)-camPos.x)/rayDir.x<(square.y+sign(rayDir.y)-camPos.y)/rayDir.y) {\n            square.x += sign(rayDir.x)*1.0;\n        } else {\n            square.y += sign(rayDir.y)*1.0;\n        }\n        \n        if(i==I_MAX-1&&rayDir.z>-0.1) {\n            color += vec3(vec2(0.5,0.15)*abs(angle)*exp(-rayDir.z*rayDir.z*30.0),0.2);\n             color += aurColor;\n        }\n\n    }\n    //fragColor = vec4( color, isGlow ? 1.0 : 0.0);\n    fragColor = vec4( color, mind);\n}\n",
      "name": "Buffer A",
      "description": "",
      "type": "buffer"
    }
  ]
}
